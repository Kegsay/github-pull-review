[
  {
    "url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23178681",
    "id": 23178681,
    "diff_hunk": "@@ -0,0 +1,393 @@\n+Client-Server v2 HTTP API Draft\n+===============================\n+\n+Filter API\n+----------\n+\n+The intersection of the parameters given defines the filter.  Unions of filters\n+can be achieved by querying multiple filters in parallel.\n+\n+XXX: Filters describe both what data to query and how to present it, so could\n+perhaps be better described as 'queries' or even 'subscriptions'?\n+\n+XXX: Is this actually sensible - should we instead have ordering & pagination &\n+limits etc provided per-query rather than lost in the filter?  Or you provide the\n+defaults in the filter definition, and then clobber them with query params.\n+\n+You can define a reusable filter with the below POST API.  The resulting filter_id\n+can then be passed to methods which can be filter.\n+\n+You can only create filters for your own user (filters are namespaced per user\n+as they are defined per-user data, like profiles etc)\n+\n+TODO: excluding filters (e.g. filter out \"org.matrix.neb.*\")\n+\n+XXX: how do we transition between non-coalesced pagination and coalesced pagination for related_to/updates\n+\n+::\n+\n+    POST /user/{userId}/filter\n+\n+.. code:: javascript    \n+    \n+    {\n+        // selectors: (bluntly selecting on the unencrypted fields)\n+        types: [ \"m.*\", \"net.arasphere.*\" ],    // default: all\n+        not_types: [ \"m.presence\" ],            // default: none\n+        rooms: [ \"!83wy7whi:matrix.org\" ],      // default: all (may be aliases or IDs. wildcards supported)\n+        not_rooms: [],\n+        senders: [ \"@matthew:matrix.org\" ],  // default: all (e.g. for narrowing down presence, and stalker mode. wildcards supported)\n+        not_senders: [],\n+        \n+        // XXX: do we want this per-query; is it valid to reuse it?\n+        // we probably don't need this as querying per-event-ID will be a parameter from a seperate API,\n+        // with its own seperate filter token & pagination semantics.\n+        event_ids: [ \"$192318719:matrix.org\" ], // default: all - useful for selecting relates_to data for a given event\n+        not_event_ids: [] // questionable\n+        \n+        // parameters\n+        \n+        // 'format' gives the desired shape of the response\n+        //   federation = include the federation layer as well as the raw content of events.\n+        //   events = the plain events\n+        format: \"federation\",\n+        \n+        // select specific specific fields of the event to be returned.\n+        // N.B. you cannot guaranteeing filter content fields as they may be encrypted.\n+        // e.g. selecting just event_id could be useful for doing server-side\n+        // sorting/pagination/threading\n+        select: [ \"event_id\", \"origin_server_ts\", \"thread_id\", \"content\", \"content.body\" ], \n+        \n+        // include bundled child-event updates (default false)\n+        bundle_updates: true,\n+        \n+        // include bundled related events\n+        bundle_relates_to: [\n+            {\n+                relationship: \"in_reply_to\",\n+                // As this is an optimisation to avoid having to explicitly select/paginate the\n+                // related messages per-message, we have to include a limit here as if we were\n+                // actually executing the query per-message for the initial result set.\n+                // Limit gives the number of related events to bundle; the bundled events return chunk tokens\n+                // to let you seperately paginate on them.\n+                limit: 10, // maximum number of related events to bundle in the results of this filtered result set.\n+                ancestors: true, // include all ancestors (default: true)\n+                descendents: true, // include all descendents (default: true)\n+                \n+                <recursively include a filter definition here for the subset of events>\n+                // need to support a sort criteria which reflects the linearised ordering of the relation graph\n+            },\n+        ],\n+        \n+        // server-side sorting, so we can paginate serverside on a thin client.\n+        // N.B. we can only order by unencrypted fields.\n+        // N.B. clients will need to handle out-of-order messages intelligently\n+        // N.B. subset of things you're allowed to sort by may be arbitrarily\n+        // restricted by the server impl (XXX: capabilities?)\n+        // Servers must support the \"timeline\" ordering - which is linearised logical chronological ordering.\n+        // N.B. This only takes effect when paginating, and is ignored for streaming data, and can only be specified once per filter.\n+        sort: [\n+            // sort by sender, and then by the timeline\n+            {   \n+                type: \"sender\",\n+                dir: \"asc\", // default asc\n+            },\n+            {   \n+                type: \"timeline\",\n+                dir: \"asc\",\n+            },\n+        ],\n+    }\n+\n+Returns ``200 OK``::\n+    \n+    {\n+        \"filter_id\": \"583e98c2d983\"\n+    }\n+\n+\n+\"Sync API\" (was Event Stream API / Global initial sync API)\n+-----------------------------------------------------------\n+\n+There is no difference between an incremental initial sync of events and polling for updates on the eventstream.  They both transfer a delta of events from the server to the client, and both deltas need to be capped to avoid DoSing the client if too much time has elapsed between syncs.  Initial sync is thus a capped incremental delta of events relative to clean client-side state.\n+\n+Therefore we propose combining them into a single /sync API.  It's important to note that we should not design out server->client pushed event updates - the data returned by /sync polling should also be suitable for pushing if available (with suitable gapping/capping to avoid DoSing the client).  XXX: do this!\n+\n+``GET /sync``\n+\n+TODO: https://matrix.org/jira/browse/SYN-168\n+    /initialSync should return the actual m.room.member invite, not random keys from it\n+\n+GET parameters::\n+\n+    limit: maximum number of events per room to return.  If this limit is exceeded:\n+           1. the server must flag the gap in the response (to avoid ambiguity between hitting the limit and exceeding the limit)\n+           2. the client must either throw away older timeline information or model a 'gap' in the timeline\n+           3. the server must include the full delta of state keys since the last sync, but will truncate the timeline delta.\n+\n+    // the sort order of messages in the room, *only honoured during an initial sync*. default: \"timeline,asc\". may appear multiple times\n+    // subsequent calls to /sync will always return event updates in timeline order (thanks to causality)\n+    // the chunk tokens per-room are dependent on the sort order and cannot be mixed between different uses of the same filter.\n+    // the use case here is to start paginating a room sorted by not-timeline (e.g. by sender id - e.g. mail client use case)\n+    sort: fieldname, direction (e.g. \"sender,asc\"). \n+    \n+    since: <chunk token> to request an incremental delta since the specified chunk token\n+        We call this 'since' rather than 'from' because it's not for pagination but a delta.\n+        The specified chunk token would be taken from the most recent sync request that completed for this filter.\n+    timeout: maximum time to poll (in milliseconds) before returning this request. Only meaningful if performing an incremental sync (i.e. `since` is set)\n+        \n+    set_presence: \"offline\" // optional parameter to tell the server not to interpret this request as a client as coming online (and as a convenience method for overriding presence state in general)\n+    \n+    presence: true/false (default true): do we want to show presence updates?",
    "path": "drafts/cs-v2-http-api.rst",
    "position": null,
    "original_position": 141,
    "commit_id": "7b7d124f24272aeaa19444994e8e3d57cb353580",
    "original_commit_id": "746b14484445847cac3b9e1dc89e38a7aad80221",
    "user": {
      "login": "leonerd",
      "id": 350941,
      "avatar_url": "https://avatars.githubusercontent.com/u/350941?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/leonerd",
      "html_url": "https://github.com/leonerd",
      "followers_url": "https://api.github.com/users/leonerd/followers",
      "following_url": "https://api.github.com/users/leonerd/following{/other_user}",
      "gists_url": "https://api.github.com/users/leonerd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/leonerd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/leonerd/subscriptions",
      "organizations_url": "https://api.github.com/users/leonerd/orgs",
      "repos_url": "https://api.github.com/users/leonerd/repos",
      "events_url": "https://api.github.com/users/leonerd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/leonerd/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "You mention presence, but what about typing? What about other ephemeral details we might one day invent?",
    "created_at": "2015-01-19T18:43:50Z",
    "updated_at": "2015-09-11T15:37:21Z",
    "html_url": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23178681",
    "pull_request_url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23178681"
      },
      "html": {
        "href": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23178681"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6"
      }
    }
  },
  {
    "url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23178722",
    "id": 23178722,
    "diff_hunk": "@@ -0,0 +1,393 @@\n+Client-Server v2 HTTP API Draft\n+===============================\n+\n+Filter API\n+----------\n+\n+The intersection of the parameters given defines the filter.  Unions of filters\n+can be achieved by querying multiple filters in parallel.\n+\n+XXX: Filters describe both what data to query and how to present it, so could\n+perhaps be better described as 'queries' or even 'subscriptions'?\n+\n+XXX: Is this actually sensible - should we instead have ordering & pagination &\n+limits etc provided per-query rather than lost in the filter?  Or you provide the\n+defaults in the filter definition, and then clobber them with query params.\n+\n+You can define a reusable filter with the below POST API.  The resulting filter_id\n+can then be passed to methods which can be filter.\n+\n+You can only create filters for your own user (filters are namespaced per user\n+as they are defined per-user data, like profiles etc)\n+\n+TODO: excluding filters (e.g. filter out \"org.matrix.neb.*\")\n+\n+XXX: how do we transition between non-coalesced pagination and coalesced pagination for related_to/updates\n+\n+::\n+\n+    POST /user/{userId}/filter\n+\n+.. code:: javascript    \n+    \n+    {\n+        // selectors: (bluntly selecting on the unencrypted fields)\n+        types: [ \"m.*\", \"net.arasphere.*\" ],    // default: all\n+        not_types: [ \"m.presence\" ],            // default: none\n+        rooms: [ \"!83wy7whi:matrix.org\" ],      // default: all (may be aliases or IDs. wildcards supported)\n+        not_rooms: [],\n+        senders: [ \"@matthew:matrix.org\" ],  // default: all (e.g. for narrowing down presence, and stalker mode. wildcards supported)\n+        not_senders: [],\n+        \n+        // XXX: do we want this per-query; is it valid to reuse it?\n+        // we probably don't need this as querying per-event-ID will be a parameter from a seperate API,\n+        // with its own seperate filter token & pagination semantics.\n+        event_ids: [ \"$192318719:matrix.org\" ], // default: all - useful for selecting relates_to data for a given event\n+        not_event_ids: [] // questionable\n+        \n+        // parameters\n+        \n+        // 'format' gives the desired shape of the response\n+        //   federation = include the federation layer as well as the raw content of events.\n+        //   events = the plain events\n+        format: \"federation\",\n+        \n+        // select specific specific fields of the event to be returned.\n+        // N.B. you cannot guaranteeing filter content fields as they may be encrypted.\n+        // e.g. selecting just event_id could be useful for doing server-side\n+        // sorting/pagination/threading\n+        select: [ \"event_id\", \"origin_server_ts\", \"thread_id\", \"content\", \"content.body\" ], \n+        \n+        // include bundled child-event updates (default false)\n+        bundle_updates: true,\n+        \n+        // include bundled related events\n+        bundle_relates_to: [\n+            {\n+                relationship: \"in_reply_to\",\n+                // As this is an optimisation to avoid having to explicitly select/paginate the\n+                // related messages per-message, we have to include a limit here as if we were\n+                // actually executing the query per-message for the initial result set.\n+                // Limit gives the number of related events to bundle; the bundled events return chunk tokens\n+                // to let you seperately paginate on them.\n+                limit: 10, // maximum number of related events to bundle in the results of this filtered result set.\n+                ancestors: true, // include all ancestors (default: true)\n+                descendents: true, // include all descendents (default: true)\n+                \n+                <recursively include a filter definition here for the subset of events>\n+                // need to support a sort criteria which reflects the linearised ordering of the relation graph\n+            },\n+        ],\n+        \n+        // server-side sorting, so we can paginate serverside on a thin client.\n+        // N.B. we can only order by unencrypted fields.\n+        // N.B. clients will need to handle out-of-order messages intelligently\n+        // N.B. subset of things you're allowed to sort by may be arbitrarily\n+        // restricted by the server impl (XXX: capabilities?)\n+        // Servers must support the \"timeline\" ordering - which is linearised logical chronological ordering.\n+        // N.B. This only takes effect when paginating, and is ignored for streaming data, and can only be specified once per filter.\n+        sort: [\n+            // sort by sender, and then by the timeline\n+            {   \n+                type: \"sender\",\n+                dir: \"asc\", // default asc\n+            },\n+            {   \n+                type: \"timeline\",\n+                dir: \"asc\",\n+            },\n+        ],\n+    }\n+\n+Returns ``200 OK``::\n+    \n+    {\n+        \"filter_id\": \"583e98c2d983\"\n+    }\n+\n+\n+\"Sync API\" (was Event Stream API / Global initial sync API)\n+-----------------------------------------------------------\n+\n+There is no difference between an incremental initial sync of events and polling for updates on the eventstream.  They both transfer a delta of events from the server to the client, and both deltas need to be capped to avoid DoSing the client if too much time has elapsed between syncs.  Initial sync is thus a capped incremental delta of events relative to clean client-side state.\n+\n+Therefore we propose combining them into a single /sync API.  It's important to note that we should not design out server->client pushed event updates - the data returned by /sync polling should also be suitable for pushing if available (with suitable gapping/capping to avoid DoSing the client).  XXX: do this!\n+\n+``GET /sync``\n+\n+TODO: https://matrix.org/jira/browse/SYN-168\n+    /initialSync should return the actual m.room.member invite, not random keys from it\n+\n+GET parameters::\n+\n+    limit: maximum number of events per room to return.  If this limit is exceeded:\n+           1. the server must flag the gap in the response (to avoid ambiguity between hitting the limit and exceeding the limit)\n+           2. the client must either throw away older timeline information or model a 'gap' in the timeline\n+           3. the server must include the full delta of state keys since the last sync, but will truncate the timeline delta.\n+\n+    // the sort order of messages in the room, *only honoured during an initial sync*. default: \"timeline,asc\". may appear multiple times\n+    // subsequent calls to /sync will always return event updates in timeline order (thanks to causality)\n+    // the chunk tokens per-room are dependent on the sort order and cannot be mixed between different uses of the same filter.\n+    // the use case here is to start paginating a room sorted by not-timeline (e.g. by sender id - e.g. mail client use case)\n+    sort: fieldname, direction (e.g. \"sender,asc\"). \n+    \n+    since: <chunk token> to request an incremental delta since the specified chunk token\n+        We call this 'since' rather than 'from' because it's not for pagination but a delta.\n+        The specified chunk token would be taken from the most recent sync request that completed for this filter.\n+    timeout: maximum time to poll (in milliseconds) before returning this request. Only meaningful if performing an incremental sync (i.e. `since` is set)\n+        \n+    set_presence: \"offline\" // optional parameter to tell the server not to interpret this request as a client as coming online (and as a convenience method for overriding presence state in general)",
    "path": "drafts/cs-v2-http-api.rst",
    "position": null,
    "original_position": 139,
    "commit_id": "7b7d124f24272aeaa19444994e8e3d57cb353580",
    "original_commit_id": "746b14484445847cac3b9e1dc89e38a7aad80221",
    "user": {
      "login": "leonerd",
      "id": 350941,
      "avatar_url": "https://avatars.githubusercontent.com/u/350941?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/leonerd",
      "html_url": "https://github.com/leonerd",
      "followers_url": "https://api.github.com/users/leonerd/followers",
      "following_url": "https://api.github.com/users/leonerd/following{/other_user}",
      "gists_url": "https://api.github.com/users/leonerd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/leonerd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/leonerd/subscriptions",
      "organizations_url": "https://api.github.com/users/leonerd/orgs",
      "repos_url": "https://api.github.com/users/leonerd/repos",
      "events_url": "https://api.github.com/users/leonerd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/leonerd/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I dislike \"set_presence\" - what if my presence isn't currently offline? This shouldn't make the presence *become* offline, it should just skip the effect that this request would otherwise set it to online.",
    "created_at": "2015-01-19T18:44:30Z",
    "updated_at": "2015-09-11T15:37:21Z",
    "html_url": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23178722",
    "pull_request_url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23178722"
      },
      "html": {
        "href": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23178722"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6"
      }
    }
  },
  {
    "url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23178912",
    "id": 23178912,
    "diff_hunk": "@@ -0,0 +1,393 @@\n+Client-Server v2 HTTP API Draft\n+===============================\n+\n+Filter API\n+----------\n+\n+The intersection of the parameters given defines the filter.  Unions of filters\n+can be achieved by querying multiple filters in parallel.\n+\n+XXX: Filters describe both what data to query and how to present it, so could\n+perhaps be better described as 'queries' or even 'subscriptions'?\n+\n+XXX: Is this actually sensible - should we instead have ordering & pagination &\n+limits etc provided per-query rather than lost in the filter?  Or you provide the\n+defaults in the filter definition, and then clobber them with query params.\n+\n+You can define a reusable filter with the below POST API.  The resulting filter_id\n+can then be passed to methods which can be filter.\n+\n+You can only create filters for your own user (filters are namespaced per user\n+as they are defined per-user data, like profiles etc)\n+\n+TODO: excluding filters (e.g. filter out \"org.matrix.neb.*\")\n+\n+XXX: how do we transition between non-coalesced pagination and coalesced pagination for related_to/updates\n+\n+::\n+\n+    POST /user/{userId}/filter\n+\n+.. code:: javascript    \n+    \n+    {\n+        // selectors: (bluntly selecting on the unencrypted fields)\n+        types: [ \"m.*\", \"net.arasphere.*\" ],    // default: all\n+        not_types: [ \"m.presence\" ],            // default: none\n+        rooms: [ \"!83wy7whi:matrix.org\" ],      // default: all (may be aliases or IDs. wildcards supported)\n+        not_rooms: [],\n+        senders: [ \"@matthew:matrix.org\" ],  // default: all (e.g. for narrowing down presence, and stalker mode. wildcards supported)\n+        not_senders: [],\n+        \n+        // XXX: do we want this per-query; is it valid to reuse it?\n+        // we probably don't need this as querying per-event-ID will be a parameter from a seperate API,\n+        // with its own seperate filter token & pagination semantics.\n+        event_ids: [ \"$192318719:matrix.org\" ], // default: all - useful for selecting relates_to data for a given event\n+        not_event_ids: [] // questionable\n+        \n+        // parameters\n+        \n+        // 'format' gives the desired shape of the response\n+        //   federation = include the federation layer as well as the raw content of events.\n+        //   events = the plain events\n+        format: \"federation\",\n+        \n+        // select specific specific fields of the event to be returned.\n+        // N.B. you cannot guaranteeing filter content fields as they may be encrypted.\n+        // e.g. selecting just event_id could be useful for doing server-side\n+        // sorting/pagination/threading\n+        select: [ \"event_id\", \"origin_server_ts\", \"thread_id\", \"content\", \"content.body\" ], \n+        \n+        // include bundled child-event updates (default false)\n+        bundle_updates: true,\n+        \n+        // include bundled related events\n+        bundle_relates_to: [\n+            {\n+                relationship: \"in_reply_to\",\n+                // As this is an optimisation to avoid having to explicitly select/paginate the\n+                // related messages per-message, we have to include a limit here as if we were\n+                // actually executing the query per-message for the initial result set.\n+                // Limit gives the number of related events to bundle; the bundled events return chunk tokens\n+                // to let you seperately paginate on them.\n+                limit: 10, // maximum number of related events to bundle in the results of this filtered result set.\n+                ancestors: true, // include all ancestors (default: true)\n+                descendents: true, // include all descendents (default: true)\n+                \n+                <recursively include a filter definition here for the subset of events>\n+                // need to support a sort criteria which reflects the linearised ordering of the relation graph\n+            },\n+        ],\n+        \n+        // server-side sorting, so we can paginate serverside on a thin client.\n+        // N.B. we can only order by unencrypted fields.\n+        // N.B. clients will need to handle out-of-order messages intelligently\n+        // N.B. subset of things you're allowed to sort by may be arbitrarily\n+        // restricted by the server impl (XXX: capabilities?)\n+        // Servers must support the \"timeline\" ordering - which is linearised logical chronological ordering.\n+        // N.B. This only takes effect when paginating, and is ignored for streaming data, and can only be specified once per filter.\n+        sort: [\n+            // sort by sender, and then by the timeline\n+            {   \n+                type: \"sender\",\n+                dir: \"asc\", // default asc\n+            },\n+            {   \n+                type: \"timeline\",\n+                dir: \"asc\",\n+            },\n+        ],\n+    }\n+\n+Returns ``200 OK``::\n+    \n+    {\n+        \"filter_id\": \"583e98c2d983\"\n+    }\n+\n+\n+\"Sync API\" (was Event Stream API / Global initial sync API)\n+-----------------------------------------------------------\n+\n+There is no difference between an incremental initial sync of events and polling for updates on the eventstream.  They both transfer a delta of events from the server to the client, and both deltas need to be capped to avoid DoSing the client if too much time has elapsed between syncs.  Initial sync is thus a capped incremental delta of events relative to clean client-side state.\n+\n+Therefore we propose combining them into a single /sync API.  It's important to note that we should not design out server->client pushed event updates - the data returned by /sync polling should also be suitable for pushing if available (with suitable gapping/capping to avoid DoSing the client).  XXX: do this!\n+\n+``GET /sync``\n+\n+TODO: https://matrix.org/jira/browse/SYN-168\n+    /initialSync should return the actual m.room.member invite, not random keys from it\n+\n+GET parameters::\n+\n+    limit: maximum number of events per room to return.  If this limit is exceeded:\n+           1. the server must flag the gap in the response (to avoid ambiguity between hitting the limit and exceeding the limit)\n+           2. the client must either throw away older timeline information or model a 'gap' in the timeline\n+           3. the server must include the full delta of state keys since the last sync, but will truncate the timeline delta.\n+\n+    // the sort order of messages in the room, *only honoured during an initial sync*. default: \"timeline,asc\". may appear multiple times\n+    // subsequent calls to /sync will always return event updates in timeline order (thanks to causality)\n+    // the chunk tokens per-room are dependent on the sort order and cannot be mixed between different uses of the same filter.\n+    // the use case here is to start paginating a room sorted by not-timeline (e.g. by sender id - e.g. mail client use case)\n+    sort: fieldname, direction (e.g. \"sender,asc\"). \n+    \n+    since: <chunk token> to request an incremental delta since the specified chunk token\n+        We call this 'since' rather than 'from' because it's not for pagination but a delta.\n+        The specified chunk token would be taken from the most recent sync request that completed for this filter.\n+    timeout: maximum time to poll (in milliseconds) before returning this request. Only meaningful if performing an incremental sync (i.e. `since` is set)\n+        \n+    set_presence: \"offline\" // optional parameter to tell the server not to interpret this request as a client as coming online (and as a convenience method for overriding presence state in general)\n+    \n+    presence: true/false (default true): do we want to show presence updates?\n+    userdata: true/false (default true): do we want to include updates to user data?\n+    \n+    backfill: true/false (default true): do we want to pull in state from federation if we have less than <limit> events available for a room?\n+             \n+    filter: <filter_id> // filters can change between requests, to allow us to narrow down a global initial sync to a given room or similar use cases.\n+    // filter overrides (useful for changing filters between requests)\n+    filter_type: wildcard event type match e.g. \"m.*\", \"m.presence\": default, all.  may appear multiple times.\n+    filter_room: wildcard room id/name match e.g. \"!83wy7whi:matrix.org\": default, all.  may appear multiple times.\n+    filter_sender: wildcard sender id match e.g. \"@matthew:matrix.org\": default, all.  may appear multiple times.\n+    filter_event_id: event id to match e.g. \"$192318719:matrix.org\" // default, all: may appear multiple times\n+    filter_format: \"federation\" or \"events\"\n+    filter_select: event fields to return: default, all.  may appear multiple times\n+    filter_bundle_updates: true/false: default, false. bundle updates in events.\n+    // we deliberately don't specify filter_bundle_relates_to, as it's too hard to serialise into querystring params\n+\n+Returns ``200 OK``:\n+\n+.. code:: javascript\n+    \n+    // where compact is false:\n+    {\n+        \"next_chunk\": \"s72595_4483_1934\", // the chunk token we pass to /sync's since param\n+        \n+        \"eventMap\": {\n+            \"$14qwtyeufet783:matrix.org\": {\n+                    \"avatar_url\": \"http://matrix.tp.mu:8008/_matrix/content/QG1hdHRoZXc6dHAubXUOeJQMWFMvUdqdeLovZKsyaOT.aW1hZ2UvanBlZw==.jpeg\",\n+                    \"displayname\": \"Matthew Hodgson\",\n+                    \"last_active_ago\": 368200528,\n+                    \"presence\": \"online\",\n+                    \"sender\": \"@matthew:tp.mu\"\n+                },\n+                \"type\": \"m.presence\", \n+                \"edu\": true, // N.B. explicitly flag EDUs as not to be stored \n+            },\n+            \n+            \"$1417731086506PgoVf:matrix.org\": {\n+                \"content\": {\n+                    \"avatar_url\": \"https://matrix.org/_matrix/content/QG1hdHRoZXc6bWF0cml4Lm9yZwxaesQWnqdynuXIYaRisFnZdG.aW1hZ2UvanBlZw==.jpeg\",\n+                    \"displayname\": \"Matthew\",\n+                    \"membership\": \"join\"\n+                },\n+                \"membership\": \"join\",\n+                \"origin_server_ts\": 1417731086795,\n+                \"prev_state\": [[\"$1416420706925RVAWP:matrix.org\", {\n+                    \"sha256\": \"zVzi02R5aeO2HQDnybu1XuuyR6yBG8utLE/i1Sv8eyA\"\n+                }\n+                ]],\n+                // \"room_id\": \"!KrLWMLDnZAyTapqLWW:matrix.org\", // remove this in compact form as it's redundant\n+                \"state_key\": \"@matthew:matrix.org\",\n+                \"type\": \"m.room.member\",\n+                \"sender\": \"@matthew:matrix.org\"    \n+            }\n+        }\n+        \n+        // updates about our own user data\n+        \"user\": {\n+            // XXX: need a way to map *our* user data (presence updates(?), profile updates, contact updates etc) into here - either as events or something else\n+        },\n+                \n+        // updates about other users' data (that the server thinks we care about - XXX: how do we filter this, beyond turning it bluntly on & off?)\n+        // XXX: Should this be combined with \"user\"?\n+        \"presence\": [\n+            \"$14qwtyeufet783:matrix.org\"\n+        ],\n+        \n+        \"rooms\": [{\n+            // \"membership\": \"join\",  // this now gets removed as redundant with state object, likewise invite keys (i.e. \"invitee\")\n+            \"events\": { // rename messages to events as this is a list of all events, not just messages (non-state events).\n+                        // gives a list of events, limited to $limit in length\n+                \"chunk\": [\n+                    \"$1417731086506PgoVf:matrix.org\", ...\n+                ],\n+                \"next_chunk\": \"s72595_4483_1934\",   // for syncing forwards, filtered just to this room? XXX: feels a bit too magical to imply a new filter...\n+                \"prev_chunk\": \"t67-41151_4483_1934\" // for scrollback\n+            },\n+            \"room_id\": \"!KrLWMLDnZAyTapqLWW:matrix.org\",\n+            \"state\": [ \"$1417731086506PgoVf:matrix.org\" ],\n+            \"limited\": true, // has the limit been exceeded for the number of events returned for this room? if so, the client should be aware that there's a gap in the event stream\n+            \"visibility\": \"public\",  // this means it's a published room... but needs to be better represented and not use the word 'public'\n+        }]\n+    }\n+    \n+Room Creation API\n+-----------------\n+\n+Joining API\n+-----------\n+\n+Room History\n+------------\n+\n+Scrollback API\n+~~~~~~~~~~~~~~\n+\n+::\n+\n+    GET /rooms/<room_id>/events\n+\n+GET parameters::\n+\n+    from: the chunk token to paginate from\n+    Otherwise same as /sync, except \"since\", \"timeout\", \"presence\" and \"set_presence\" are not implemented\n+\n+Returns ``200 OK``:\n+\n+.. code:: javascript\n+\n+    // events precisely as per a room's events key as returned by sync, with the events expanded out inline\n+    {\n+        \"chunk\": [{\n+            \"age\": 28153452, // how long as the destination HS had the message + how long the origin HS had the message",
    "path": "drafts/cs-v2-http-api.rst",
    "position": null,
    "original_position": 252,
    "commit_id": "7b7d124f24272aeaa19444994e8e3d57cb353580",
    "original_commit_id": "746b14484445847cac3b9e1dc89e38a7aad80221",
    "user": {
      "login": "leonerd",
      "id": 350941,
      "avatar_url": "https://avatars.githubusercontent.com/u/350941?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/leonerd",
      "html_url": "https://github.com/leonerd",
      "followers_url": "https://api.github.com/users/leonerd/followers",
      "following_url": "https://api.github.com/users/leonerd/following{/other_user}",
      "gists_url": "https://api.github.com/users/leonerd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/leonerd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/leonerd/subscriptions",
      "organizations_url": "https://api.github.com/users/leonerd/orgs",
      "repos_url": "https://api.github.com/users/leonerd/repos",
      "events_url": "https://api.github.com/users/leonerd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/leonerd/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Units?",
    "created_at": "2015-01-19T18:47:56Z",
    "updated_at": "2015-09-11T15:37:21Z",
    "html_url": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23178912",
    "pull_request_url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23178912"
      },
      "html": {
        "href": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23178912"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6"
      }
    }
  },
  {
    "url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23179361",
    "id": 23179361,
    "diff_hunk": "@@ -0,0 +1,393 @@\n+Client-Server v2 HTTP API Draft\n+===============================\n+\n+Filter API\n+----------\n+\n+The intersection of the parameters given defines the filter.  Unions of filters\n+can be achieved by querying multiple filters in parallel.\n+\n+XXX: Filters describe both what data to query and how to present it, so could\n+perhaps be better described as 'queries' or even 'subscriptions'?\n+\n+XXX: Is this actually sensible - should we instead have ordering & pagination &\n+limits etc provided per-query rather than lost in the filter?  Or you provide the\n+defaults in the filter definition, and then clobber them with query params.\n+\n+You can define a reusable filter with the below POST API.  The resulting filter_id\n+can then be passed to methods which can be filter.\n+\n+You can only create filters for your own user (filters are namespaced per user\n+as they are defined per-user data, like profiles etc)\n+\n+TODO: excluding filters (e.g. filter out \"org.matrix.neb.*\")\n+\n+XXX: how do we transition between non-coalesced pagination and coalesced pagination for related_to/updates\n+\n+::\n+\n+    POST /user/{userId}/filter\n+\n+.. code:: javascript    \n+    \n+    {\n+        // selectors: (bluntly selecting on the unencrypted fields)\n+        types: [ \"m.*\", \"net.arasphere.*\" ],    // default: all\n+        not_types: [ \"m.presence\" ],            // default: none\n+        rooms: [ \"!83wy7whi:matrix.org\" ],      // default: all (may be aliases or IDs. wildcards supported)\n+        not_rooms: [],\n+        senders: [ \"@matthew:matrix.org\" ],  // default: all (e.g. for narrowing down presence, and stalker mode. wildcards supported)\n+        not_senders: [],\n+        \n+        // XXX: do we want this per-query; is it valid to reuse it?\n+        // we probably don't need this as querying per-event-ID will be a parameter from a seperate API,\n+        // with its own seperate filter token & pagination semantics.\n+        event_ids: [ \"$192318719:matrix.org\" ], // default: all - useful for selecting relates_to data for a given event\n+        not_event_ids: [] // questionable\n+        \n+        // parameters\n+        \n+        // 'format' gives the desired shape of the response\n+        //   federation = include the federation layer as well as the raw content of events.\n+        //   events = the plain events\n+        format: \"federation\",\n+        \n+        // select specific specific fields of the event to be returned.\n+        // N.B. you cannot guaranteeing filter content fields as they may be encrypted.\n+        // e.g. selecting just event_id could be useful for doing server-side\n+        // sorting/pagination/threading\n+        select: [ \"event_id\", \"origin_server_ts\", \"thread_id\", \"content\", \"content.body\" ], \n+        \n+        // include bundled child-event updates (default false)\n+        bundle_updates: true,\n+        \n+        // include bundled related events\n+        bundle_relates_to: [\n+            {\n+                relationship: \"in_reply_to\",\n+                // As this is an optimisation to avoid having to explicitly select/paginate the\n+                // related messages per-message, we have to include a limit here as if we were\n+                // actually executing the query per-message for the initial result set.\n+                // Limit gives the number of related events to bundle; the bundled events return chunk tokens\n+                // to let you seperately paginate on them.\n+                limit: 10, // maximum number of related events to bundle in the results of this filtered result set.\n+                ancestors: true, // include all ancestors (default: true)\n+                descendents: true, // include all descendents (default: true)\n+                \n+                <recursively include a filter definition here for the subset of events>\n+                // need to support a sort criteria which reflects the linearised ordering of the relation graph\n+            },\n+        ],\n+        \n+        // server-side sorting, so we can paginate serverside on a thin client.\n+        // N.B. we can only order by unencrypted fields.\n+        // N.B. clients will need to handle out-of-order messages intelligently\n+        // N.B. subset of things you're allowed to sort by may be arbitrarily\n+        // restricted by the server impl (XXX: capabilities?)\n+        // Servers must support the \"timeline\" ordering - which is linearised logical chronological ordering.\n+        // N.B. This only takes effect when paginating, and is ignored for streaming data, and can only be specified once per filter.\n+        sort: [\n+            // sort by sender, and then by the timeline\n+            {   \n+                type: \"sender\",\n+                dir: \"asc\", // default asc\n+            },\n+            {   \n+                type: \"timeline\",\n+                dir: \"asc\",\n+            },\n+        ],\n+    }\n+\n+Returns ``200 OK``::\n+    \n+    {\n+        \"filter_id\": \"583e98c2d983\"\n+    }\n+\n+\n+\"Sync API\" (was Event Stream API / Global initial sync API)\n+-----------------------------------------------------------\n+\n+There is no difference between an incremental initial sync of events and polling for updates on the eventstream.  They both transfer a delta of events from the server to the client, and both deltas need to be capped to avoid DoSing the client if too much time has elapsed between syncs.  Initial sync is thus a capped incremental delta of events relative to clean client-side state.\n+\n+Therefore we propose combining them into a single /sync API.  It's important to note that we should not design out server->client pushed event updates - the data returned by /sync polling should also be suitable for pushing if available (with suitable gapping/capping to avoid DoSing the client).  XXX: do this!\n+\n+``GET /sync``\n+\n+TODO: https://matrix.org/jira/browse/SYN-168\n+    /initialSync should return the actual m.room.member invite, not random keys from it\n+\n+GET parameters::\n+\n+    limit: maximum number of events per room to return.  If this limit is exceeded:\n+           1. the server must flag the gap in the response (to avoid ambiguity between hitting the limit and exceeding the limit)\n+           2. the client must either throw away older timeline information or model a 'gap' in the timeline\n+           3. the server must include the full delta of state keys since the last sync, but will truncate the timeline delta.\n+\n+    // the sort order of messages in the room, *only honoured during an initial sync*. default: \"timeline,asc\". may appear multiple times\n+    // subsequent calls to /sync will always return event updates in timeline order (thanks to causality)\n+    // the chunk tokens per-room are dependent on the sort order and cannot be mixed between different uses of the same filter.\n+    // the use case here is to start paginating a room sorted by not-timeline (e.g. by sender id - e.g. mail client use case)\n+    sort: fieldname, direction (e.g. \"sender,asc\"). \n+    \n+    since: <chunk token> to request an incremental delta since the specified chunk token\n+        We call this 'since' rather than 'from' because it's not for pagination but a delta.\n+        The specified chunk token would be taken from the most recent sync request that completed for this filter.\n+    timeout: maximum time to poll (in milliseconds) before returning this request. Only meaningful if performing an incremental sync (i.e. `since` is set)\n+        \n+    set_presence: \"offline\" // optional parameter to tell the server not to interpret this request as a client as coming online (and as a convenience method for overriding presence state in general)\n+    \n+    presence: true/false (default true): do we want to show presence updates?\n+    userdata: true/false (default true): do we want to include updates to user data?\n+    \n+    backfill: true/false (default true): do we want to pull in state from federation if we have less than <limit> events available for a room?\n+             \n+    filter: <filter_id> // filters can change between requests, to allow us to narrow down a global initial sync to a given room or similar use cases.\n+    // filter overrides (useful for changing filters between requests)\n+    filter_type: wildcard event type match e.g. \"m.*\", \"m.presence\": default, all.  may appear multiple times.\n+    filter_room: wildcard room id/name match e.g. \"!83wy7whi:matrix.org\": default, all.  may appear multiple times.\n+    filter_sender: wildcard sender id match e.g. \"@matthew:matrix.org\": default, all.  may appear multiple times.\n+    filter_event_id: event id to match e.g. \"$192318719:matrix.org\" // default, all: may appear multiple times\n+    filter_format: \"federation\" or \"events\"\n+    filter_select: event fields to return: default, all.  may appear multiple times\n+    filter_bundle_updates: true/false: default, false. bundle updates in events.\n+    // we deliberately don't specify filter_bundle_relates_to, as it's too hard to serialise into querystring params\n+\n+Returns ``200 OK``:\n+\n+.. code:: javascript\n+    \n+    // where compact is false:\n+    {\n+        \"next_chunk\": \"s72595_4483_1934\", // the chunk token we pass to /sync's since param\n+        \n+        \"eventMap\": {\n+            \"$14qwtyeufet783:matrix.org\": {\n+                    \"avatar_url\": \"http://matrix.tp.mu:8008/_matrix/content/QG1hdHRoZXc6dHAubXUOeJQMWFMvUdqdeLovZKsyaOT.aW1hZ2UvanBlZw==.jpeg\",\n+                    \"displayname\": \"Matthew Hodgson\",\n+                    \"last_active_ago\": 368200528,\n+                    \"presence\": \"online\",\n+                    \"sender\": \"@matthew:tp.mu\"\n+                },\n+                \"type\": \"m.presence\", \n+                \"edu\": true, // N.B. explicitly flag EDUs as not to be stored \n+            },\n+            \n+            \"$1417731086506PgoVf:matrix.org\": {\n+                \"content\": {\n+                    \"avatar_url\": \"https://matrix.org/_matrix/content/QG1hdHRoZXc6bWF0cml4Lm9yZwxaesQWnqdynuXIYaRisFnZdG.aW1hZ2UvanBlZw==.jpeg\",\n+                    \"displayname\": \"Matthew\",\n+                    \"membership\": \"join\"\n+                },\n+                \"membership\": \"join\",\n+                \"origin_server_ts\": 1417731086795,\n+                \"prev_state\": [[\"$1416420706925RVAWP:matrix.org\", {\n+                    \"sha256\": \"zVzi02R5aeO2HQDnybu1XuuyR6yBG8utLE/i1Sv8eyA\"\n+                }\n+                ]],\n+                // \"room_id\": \"!KrLWMLDnZAyTapqLWW:matrix.org\", // remove this in compact form as it's redundant\n+                \"state_key\": \"@matthew:matrix.org\",\n+                \"type\": \"m.room.member\",\n+                \"sender\": \"@matthew:matrix.org\"    \n+            }\n+        }\n+        \n+        // updates about our own user data\n+        \"user\": {\n+            // XXX: need a way to map *our* user data (presence updates(?), profile updates, contact updates etc) into here - either as events or something else\n+        },\n+                \n+        // updates about other users' data (that the server thinks we care about - XXX: how do we filter this, beyond turning it bluntly on & off?)\n+        // XXX: Should this be combined with \"user\"?\n+        \"presence\": [\n+            \"$14qwtyeufet783:matrix.org\"\n+        ],\n+        \n+        \"rooms\": [{\n+            // \"membership\": \"join\",  // this now gets removed as redundant with state object, likewise invite keys (i.e. \"invitee\")\n+            \"events\": { // rename messages to events as this is a list of all events, not just messages (non-state events).\n+                        // gives a list of events, limited to $limit in length\n+                \"chunk\": [\n+                    \"$1417731086506PgoVf:matrix.org\", ...\n+                ],\n+                \"next_chunk\": \"s72595_4483_1934\",   // for syncing forwards, filtered just to this room? XXX: feels a bit too magical to imply a new filter...\n+                \"prev_chunk\": \"t67-41151_4483_1934\" // for scrollback\n+            },\n+            \"room_id\": \"!KrLWMLDnZAyTapqLWW:matrix.org\",\n+            \"state\": [ \"$1417731086506PgoVf:matrix.org\" ],\n+            \"limited\": true, // has the limit been exceeded for the number of events returned for this room? if so, the client should be aware that there's a gap in the event stream\n+            \"visibility\": \"public\",  // this means it's a published room... but needs to be better represented and not use the word 'public'\n+        }]\n+    }\n+    \n+Room Creation API\n+-----------------\n+\n+Joining API\n+-----------\n+\n+Room History\n+------------\n+\n+Scrollback API\n+~~~~~~~~~~~~~~\n+\n+::\n+\n+    GET /rooms/<room_id>/events\n+\n+GET parameters::\n+\n+    from: the chunk token to paginate from\n+    Otherwise same as /sync, except \"since\", \"timeout\", \"presence\" and \"set_presence\" are not implemented\n+\n+Returns ``200 OK``:\n+\n+.. code:: javascript\n+\n+    // events precisely as per a room's events key as returned by sync, with the events expanded out inline\n+    {\n+        \"chunk\": [{\n+            \"age\": 28153452, // how long as the destination HS had the message + how long the origin HS had the message\n+            \"content\": {\n+                \"body\": \"but obviously the XSF believes XMPP is the One True Way\",\n+                \"msgtype\": \"m.text\"\n+            },\n+            \"event_id\": \"$1421165049511TJpDp:matrix.org\",\n+            \"origin_server_ts\": 1421165049435,\n+            \"room_id\": \"!cURbafjkfsMDVwdRDQ:matrix.org\",\n+            \"type\": \"m.room.message\",\n+            \"sender\": \"@irc_Arathorn:matrix.org\"\n+        }, {\n+            \"age\": 28167245,\n+            \"content\": {\n+                \"body\": \"which is all fair enough\",\n+                \"msgtype\": \"m.text\"\n+            },\n+            \"event_id\": \"$1421165035510CBwsU:matrix.org\",\n+            \"origin_server_ts\": 1421165035643,\n+            \"room_id\": \"!cURbafjkfsMDVwdRDQ:matrix.org\",\n+            \"type\": \"m.room.message\",\n+            \"sender\": \"@irc_Arathorn:matrix.org\"\n+        }],\n+        \"prev_chunk\": \"t9571-74545_2470_979\",\n+    }\n+\n+Contextual windowing API\n+~~~~~~~~~~~~~~~~~~~~~~~~\n+::\n+\n+    GET /events/<event_id>\n+\n+GET parameters::\n+\n+    context: \"before\", \"after\" or \"around\"\n+    Otherwise same as sync, without \"since\", \"presence\", \"timeout\" and \"set_presence\"\n+    \n+Returns ``200 OK``:\n+\n+.. code:: javascript\n+\n+    // the room in question, formatted exactly as a room entry returned by /sync with the events expanded out inline\n+    // with the event in question present in the list as determined by the context param\n+    {\n+        \"event_map\": {\n+            \"$1417731086506PgoVf:matrix.org\": {\n+                \"content\": {\n+                    \"avatar_url\": \"https://matrix.org/_matrix/content/QG1hdHRoZXc6bWF0cml4Lm9yZwxaesQWnqdynuXIYaRisFnZdG.aW1hZ2UvanBlZw==.jpeg\",\n+                    \"displayname\": \"Matthew\",\n+                    \"membership\": \"join\"\n+                },\n+                \"membership\": \"join\",\n+                \"origin_server_ts\": 1417731086795,\n+                \"prev_state\": [[\"$1416420706925RVAWP:matrix.org\", {\n+                    \"sha256\": \"zVzi02R5aeO2HQDnybu1XuuyR6yBG8utLE/i1Sv8eyA\"\n+                }\n+                ]],\n+                \"room_id\": \"!KrLWMLDnZAyTapqLWW:matrix.org\",\n+                \"state_key\": \"@matthew:matrix.org\",\n+                \"type\": \"m.room.member\",\n+                \"sender\": \"@matthew:matrix.org\"    \n+            }\n+        },\n+        \"membership\": \"join\",\n+        \"events\": {\n+            \"chunk\": [ \"$1417731086506PgoVf:matrix.org\" ],\n+            \"next_chunk\": \"s72595_4483_1934\",\n+            \"prev_chunk\": \"t67-41151_4483_1934\"\n+        },\n+        \"room_id\": \"!KrLWMLDnZAyTapqLWW:matrix.org\",\n+        \"state\": [ \"$1417731086506PgoVf:matrix.org\" ],\n+        \"visibility\": \"public\"\n+    }\n+\n+\n+Room Alias API\n+--------------\n+\n+Room Directory API\n+------------------\n+\n+User Profile API\n+----------------\n+\n+Provides arbitrary per-user global state JSON storage with namespaced keys,\n+some of which have specific predefined serverside semantics. Keys must be named\n+(we don't support POSTing to anonymous key names)\n+\n+::\n+\n+    PUT /user/{userId}/data/m.displayname\n+    PUT /user/{userId}/data/m.avatar_url\n+    PUT /user/{userId}/data/m.contact_vcard\n+    PUT /user/{userId}/data/net.arasphere.client.preferences\n+\n+Address Book API\n+----------------\n+\n+FIXME: XXX: Dave - can we do better than this?\n+\n+Store basic JSON vcards into per-user data.\n+\n+::\n+    PUT /user/{userId}/contacts/{deviceId}?baseVer=???\n+    { bulk incremental update of contacts relative to baseVer, keyed by an contactId (as defined by the client) }\n+    returns the new 'ver' version of the updated contact datastructure\n+\n+    GET /user/{userId}/contacts/{deviceId}?baseVer=???\n+    returns the delta of contact information for this device since baseVer.\n+\n+\n+Account Management API\n+----------------------\n+\n+Actions API\n+-----------\n+\n+Presence API\n+------------\n+\n+::\n+\n+    PUT /user/{userId}/presence/m.status // set DND/asleep/on holiday etc -\n+    // XXX: do we need to distinguish between internationalisable presets like DND\n+    // and free-form textual status messages?\n+    // XXX: should this be in /user/{userId}/data/m.status instead?\n+    // what's actually the difference? surely status is no different to avatar\n+    // updates in terms of needing to be pushed around\n+    \n+    PUT /device/{deviceId}/presence/m.presence // explicitly set online/idle/offline",
    "path": "drafts/cs-v2-http-api.rst",
    "position": null,
    "original_position": 380,
    "commit_id": "7b7d124f24272aeaa19444994e8e3d57cb353580",
    "original_commit_id": "746b14484445847cac3b9e1dc89e38a7aad80221",
    "user": {
      "login": "leonerd",
      "id": 350941,
      "avatar_url": "https://avatars.githubusercontent.com/u/350941?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/leonerd",
      "html_url": "https://github.com/leonerd",
      "followers_url": "https://api.github.com/users/leonerd/followers",
      "following_url": "https://api.github.com/users/leonerd/following{/other_user}",
      "gists_url": "https://api.github.com/users/leonerd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/leonerd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/leonerd/subscriptions",
      "organizations_url": "https://api.github.com/users/leonerd/orgs",
      "repos_url": "https://api.github.com/users/leonerd/repos",
      "events_url": "https://api.github.com/users/leonerd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/leonerd/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I don't believe we're doing per-device status information",
    "created_at": "2015-01-19T18:55:32Z",
    "updated_at": "2015-09-11T15:37:21Z",
    "html_url": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23179361",
    "pull_request_url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23179361"
      },
      "html": {
        "href": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23179361"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6"
      }
    }
  },
  {
    "url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23454573",
    "id": 23454573,
    "diff_hunk": "@@ -0,0 +1,553 @@\n+Client-Server v2 HTTP API Draft\n+===============================\n+\n+Filter API\n+----------\n+\n+The intersection of the parameters given defines the filter.  Unions of filters\n+can be achieved by querying multiple filters in parallel.\n+\n+XXX: Filters describe both what data to query and how to present it, so could\n+perhaps be better described as 'queries' or even 'subscriptions'?\n+\n+XXX: Is this actually sensible - should we instead have ordering & pagination &\n+limits etc provided per-query rather than lost in the filter?  Or you provide the\n+defaults in the filter definition, and then clobber them with query params.\n+\n+You can define a reusable filter with the below POST API.  The resulting filter_id\n+can then be passed to methods which can be filter.\n+\n+You can only create filters for your own user (filters are namespaced per user\n+as they are defined per-user data, like profiles etc)\n+\n+TODO: excluding filters (e.g. filter out \"org.matrix.neb.*\")\n+\n+XXX: how do we transition between non-coalesced pagination and coalesced pagination for related_to/updates\n+\n+::\n+\n+    POST /user/{userId}/filter\n+\n+.. code:: javascript    \n+    \n+    {\n+        // selectors: (bluntly selecting on the unencrypted fields)\n+        types: [ \"m.*\", \"net.arasphere.*\" ],    // default: all\n+        // N.B. types can be used to filter out presence and server-generated events (e.g. m.profile), but see *_user_data below\n+        not_types: [ \"m.presence\" ],            // default: none\n+        rooms: [ \"!83wy7whi:matrix.org\" ],      // default: all (may be aliases or IDs. wildcards supported)\n+        not_rooms: [],\n+        senders: [ \"@matthew:matrix.org\" ],  // default: all (e.g. for narrowing down presence, and stalker mode. wildcards supported)\n+        not_senders: [],\n+        \n+        public_user_data: true,  // include events describing public user data (as we might not know their types) - default: true\n+        private_user_data: true, // include events describing private user data (as we might not know their types) - default: true\n+        // XXX: How do these interact with specific type/non_type selectors prioritywise?\n+                \n+        // parameters\n+        \n+        // 'format' gives the desired shape of the response\n+        //   federation = include the federation layer as well as the raw content of events.\n+        //   events = the plain events\n+        format: \"federation\",\n+        \n+        // select specific specific fields of the event to be returned.\n+        // N.B. you cannot guaranteeing filter content fields as they may be encrypted.\n+        // e.g. selecting just event_id could be useful for doing server-side\n+        // sorting/pagination/threading\n+        select: [ \"event_id\", \"origin_server_ts\", \"thread_id\", \"content\", \"content.body\" ], \n+        \n+        // include bundled child-event updates (default false) // V2.0\n+        bundle_updates: true,\n+        \n+        // include bundled related events: // V2.1\n+        bundle_relates_to: [\n+            {\n+                relationship: \"in_reply_to\",\n+                // As this is an optimisation to avoid having to explicitly select/paginate the\n+                // related messages per-message, we have to include a limit here as if we were\n+                // actually executing the query per-message for the initial result set.\n+                // Limit gives the number of related events to bundle; the bundled events return batch tokens\n+                // to let you seperately paginate on them.\n+                limit: 10, // maximum number of related events to bundle in the results of this filtered result set.\n+                ancestors: true, // include all ancestors (default: true)\n+                descendents: true, // include all descendents (default: true)\n+                \n+                <recursively include a filter definition here for the subset of events>\n+                // need to support a sort criteria which reflects the linearised ordering of the relation graph\n+            },\n+        ],\n+                \n+        // XXX: we may also want room_sort to specify the order of rooms returned by /sync,\n+        // as well as pagination for rooms returned by /sync...\n+    }\n+\n+Returns ``200 OK``::\n+    \n+    {\n+        \"filter_id\": \"583e98c2d983\"\n+    }\n+\n+\n+\"Sync API\" (was Event Stream API / Global initial sync API)\n+-----------------------------------------------------------\n+\n+There is no difference between an incremental initial sync of events and polling for updates on the eventstream.  They both transfer a delta of events from the server to the client, and both deltas need to be capped to avoid DoSing the client if too much time has elapsed between syncs.  Initial sync is thus a capped incremental delta of events relative to clean client-side state.\n+\n+Therefore we propose combining them into a single /sync API.  It's important to note that we should not design out server->client pushed event updates - the data returned by /sync polling should also be suitable for pushing if available (with suitable gapping/capping to avoid DoSing the client).  XXX: do this!\n+\n+``GET /sync``\n+\n+TODO: https://matrix.org/jira/browse/SYN-168\n+    /initialSync should return the actual m.room.member invite, not random keys from it\n+\n+GET parameters::\n+\n+    limit: maximum number of events per room to return.  If this limit is exceeded and gap is true:\n+            1. the server must flag the gap in the response (to avoid ambiguity between hitting the limit and exceeding the limit)\n+            2. the client must either throw away older timeline information or model a 'gap' in the timeline\n+            3. the server must include the full delta of state keys since the last sync, but will truncate the timeline delta.\n+           If this limit is exceeded and gap is false:\n+            1. we just send through the next batch of events in the next call to /sync, without any gapping.\n+           \n+    gap: boolean - should we drop events and do a non-delta sync for rooms whose limit is exceeded.  default: true.\n+\n+    // server-side sorting, so we can paginate events serverside on a thin client.\n+    // N.B. we can only order by unencrypted fields.\n+    // N.B. clients will need to handle out-of-order messages intelligently\n+    // N.B. subset of things you're allowed to sort by may be arbitrarily\n+    // restricted by the server impl (XXX: capabilities?)\n+    // Servers MUST support the \"timeline\" ordering - which is linearised logical chronological ordering.\n+    // N.B. This only takes effect when paginating, and is ignored for streaming data, and can only be specified once per filter.\n+    //\n+    // the sort order of messages in the room, *only honoured during an initial sync*. default: \"timeline,asc\". may appear multiple times\n+    // subsequent calls to /sync will always return event updates in timeline order (thanks to causality)",
    "path": "drafts/cs-v2-http-api.rst",
    "position": null,
    "original_position": 124,
    "commit_id": "7b7d124f24272aeaa19444994e8e3d57cb353580",
    "original_commit_id": "bc087585232627c1354b4af694e990c02d78365a",
    "user": {
      "login": "NegativeMjark",
      "id": 904009,
      "avatar_url": "https://avatars.githubusercontent.com/u/904009?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/NegativeMjark",
      "html_url": "https://github.com/NegativeMjark",
      "followers_url": "https://api.github.com/users/NegativeMjark/followers",
      "following_url": "https://api.github.com/users/NegativeMjark/following{/other_user}",
      "gists_url": "https://api.github.com/users/NegativeMjark/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/NegativeMjark/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/NegativeMjark/subscriptions",
      "organizations_url": "https://api.github.com/users/NegativeMjark/orgs",
      "repos_url": "https://api.github.com/users/NegativeMjark/repos",
      "events_url": "https://api.github.com/users/NegativeMjark/events{/privacy}",
      "received_events_url": "https://api.github.com/users/NegativeMjark/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This should say \"return event updates in the order they arrive at the server\" rather than \"timeline order\". Since timeline order is different from the arrival ordering.",
    "created_at": "2015-01-23T15:06:50Z",
    "updated_at": "2015-09-11T15:37:21Z",
    "html_url": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23454573",
    "pull_request_url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23454573"
      },
      "html": {
        "href": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23454573"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6"
      }
    }
  },
  {
    "url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23454707",
    "id": 23454707,
    "diff_hunk": "@@ -0,0 +1,553 @@\n+Client-Server v2 HTTP API Draft\n+===============================\n+\n+Filter API\n+----------\n+\n+The intersection of the parameters given defines the filter.  Unions of filters\n+can be achieved by querying multiple filters in parallel.\n+\n+XXX: Filters describe both what data to query and how to present it, so could\n+perhaps be better described as 'queries' or even 'subscriptions'?\n+\n+XXX: Is this actually sensible - should we instead have ordering & pagination &\n+limits etc provided per-query rather than lost in the filter?  Or you provide the\n+defaults in the filter definition, and then clobber them with query params.\n+\n+You can define a reusable filter with the below POST API.  The resulting filter_id\n+can then be passed to methods which can be filter.\n+\n+You can only create filters for your own user (filters are namespaced per user\n+as they are defined per-user data, like profiles etc)\n+\n+TODO: excluding filters (e.g. filter out \"org.matrix.neb.*\")\n+\n+XXX: how do we transition between non-coalesced pagination and coalesced pagination for related_to/updates\n+\n+::\n+\n+    POST /user/{userId}/filter\n+\n+.. code:: javascript    \n+    \n+    {\n+        // selectors: (bluntly selecting on the unencrypted fields)\n+        types: [ \"m.*\", \"net.arasphere.*\" ],    // default: all\n+        // N.B. types can be used to filter out presence and server-generated events (e.g. m.profile), but see *_user_data below\n+        not_types: [ \"m.presence\" ],            // default: none\n+        rooms: [ \"!83wy7whi:matrix.org\" ],      // default: all (may be aliases or IDs. wildcards supported)\n+        not_rooms: [],\n+        senders: [ \"@matthew:matrix.org\" ],  // default: all (e.g. for narrowing down presence, and stalker mode. wildcards supported)\n+        not_senders: [],\n+        \n+        public_user_data: true,  // include events describing public user data (as we might not know their types) - default: true\n+        private_user_data: true, // include events describing private user data (as we might not know their types) - default: true\n+        // XXX: How do these interact with specific type/non_type selectors prioritywise?\n+                \n+        // parameters\n+        \n+        // 'format' gives the desired shape of the response\n+        //   federation = include the federation layer as well as the raw content of events.\n+        //   events = the plain events\n+        format: \"federation\",\n+        \n+        // select specific specific fields of the event to be returned.\n+        // N.B. you cannot guaranteeing filter content fields as they may be encrypted.\n+        // e.g. selecting just event_id could be useful for doing server-side\n+        // sorting/pagination/threading\n+        select: [ \"event_id\", \"origin_server_ts\", \"thread_id\", \"content\", \"content.body\" ], \n+        \n+        // include bundled child-event updates (default false) // V2.0\n+        bundle_updates: true,\n+        \n+        // include bundled related events: // V2.1\n+        bundle_relates_to: [\n+            {\n+                relationship: \"in_reply_to\",\n+                // As this is an optimisation to avoid having to explicitly select/paginate the\n+                // related messages per-message, we have to include a limit here as if we were\n+                // actually executing the query per-message for the initial result set.\n+                // Limit gives the number of related events to bundle; the bundled events return batch tokens\n+                // to let you seperately paginate on them.\n+                limit: 10, // maximum number of related events to bundle in the results of this filtered result set.\n+                ancestors: true, // include all ancestors (default: true)\n+                descendents: true, // include all descendents (default: true)\n+                \n+                <recursively include a filter definition here for the subset of events>\n+                // need to support a sort criteria which reflects the linearised ordering of the relation graph\n+            },\n+        ],\n+                \n+        // XXX: we may also want room_sort to specify the order of rooms returned by /sync,\n+        // as well as pagination for rooms returned by /sync...\n+    }\n+\n+Returns ``200 OK``::\n+    \n+    {\n+        \"filter_id\": \"583e98c2d983\"\n+    }\n+\n+\n+\"Sync API\" (was Event Stream API / Global initial sync API)\n+-----------------------------------------------------------\n+\n+There is no difference between an incremental initial sync of events and polling for updates on the eventstream.  They both transfer a delta of events from the server to the client, and both deltas need to be capped to avoid DoSing the client if too much time has elapsed between syncs.  Initial sync is thus a capped incremental delta of events relative to clean client-side state.\n+\n+Therefore we propose combining them into a single /sync API.  It's important to note that we should not design out server->client pushed event updates - the data returned by /sync polling should also be suitable for pushing if available (with suitable gapping/capping to avoid DoSing the client).  XXX: do this!\n+\n+``GET /sync``\n+\n+TODO: https://matrix.org/jira/browse/SYN-168\n+    /initialSync should return the actual m.room.member invite, not random keys from it\n+\n+GET parameters::\n+\n+    limit: maximum number of events per room to return.  If this limit is exceeded and gap is true:\n+            1. the server must flag the gap in the response (to avoid ambiguity between hitting the limit and exceeding the limit)\n+            2. the client must either throw away older timeline information or model a 'gap' in the timeline\n+            3. the server must include the full delta of state keys since the last sync, but will truncate the timeline delta.\n+           If this limit is exceeded and gap is false:\n+            1. we just send through the next batch of events in the next call to /sync, without any gapping.\n+           \n+    gap: boolean - should we drop events and do a non-delta sync for rooms whose limit is exceeded.  default: true.\n+\n+    // server-side sorting, so we can paginate events serverside on a thin client.\n+    // N.B. we can only order by unencrypted fields.\n+    // N.B. clients will need to handle out-of-order messages intelligently\n+    // N.B. subset of things you're allowed to sort by may be arbitrarily\n+    // restricted by the server impl (XXX: capabilities?)\n+    // Servers MUST support the \"timeline\" ordering - which is linearised logical chronological ordering.\n+    // N.B. This only takes effect when paginating, and is ignored for streaming data, and can only be specified once per filter.\n+    //\n+    // the sort order of messages in the room, *only honoured during an initial sync*. default: \"timeline,asc\". may appear multiple times\n+    // subsequent calls to /sync will always return event updates in timeline order (thanks to causality)\n+    // the batch tokens per-room are dependent on the sort order and cannot be mixed between different uses of the same filter.\n+    // the use case here is to start paginating a room sorted by not-timeline (e.g. by sender id - e.g. mail client use case)\n+    sort: fieldname, direction (e.g. \"sender,asc\",).\n+    \n+    // XXX: this needs to be made prettier.  you can't be a boolean because normal server behaviour allows small misorderings.\n+    // This this is an optimisation to allow thin clients to save bandwidth and not see out-of-order events which they can't\n+    // do anything useful with.  However, small races should be allowed.\n+    // v2.1\n+    // exclude_out_of_order_events_older_than: 10000 // ignore misorderings worse than 10s\n+    \n+    since: <batch token> to request an incremental delta since the specified batch token\n+        We call this 'since' rather than 'from' because it's not for pagination but a delta.\n+        The specified batch token would be taken from the most recent sync request that completed for this filter.\n+    timeout: maximum time to poll (in milliseconds) before returning this request. Only meaningful if performing an incremental sync (i.e. `since` is set)\n+        \n+    set_presence: \"offline\" // optional parameter to tell the server not to interpret this request as a client (device) as coming online (and as a convenience method for overriding presence state in general - e.g. setting straight to \"idle\" rather than having to PUT to /users/{userId}/devices/{deviceId}/presence.  It's meaningless to set \"online\" as that's the default behaviour on the server.)\n+        \n+    backfill: true/false (default true): do we want to pull in state from federation if we have less than <limit> events available for a room?\n+    \n+    filter: <filter_id> // filters can change between requests, to allow us to narrow down a global initial sync to a given room or similar use cases.\n+    // filter overrides (useful for changing filters between requests)\n+    filter_type: wildcard event type match e.g. \"m.*\", \"m.presence\": default, all.  may appear multiple times.\n+    filter_room: wildcard room id/name match e.g. \"!83wy7whi:matrix.org\": default, all.  may appear multiple times.\n+    filter_sender: wildcard sender id match e.g. \"@matthew:matrix.org\": default, all.  may appear multiple times.\n+    filter_event_id: event id to match e.g. \"$192318719:matrix.org\" // default, all: may appear multiple times\n+    filter_format: \"federation\" or \"events\"\n+    filter_select: event fields to return: default, all.  may appear multiple times\n+    filter_bundle_updates: true/false: default, false. bundle updates in events.\n+    // we deliberately don't specify filter_bundle_relates_to, as it's too hard to serialise into querystring params\n+\n+Returns ``200 OK``:\n+\n+.. code:: javascript\n+    \n+    {\n+        \"next_batch\": \"s72595_4483_1934\", // the batch token we pass to /sync's since param\n+        \n+        // updates about our own user data\n+        \"private_user_data\": [\n+            {\n+                \"event_id\": \"$15zxhijvwguye:matrix.org\",\n+                \"sender\": \"@matthew:tp.mu\"\n+                type: \"net.arasphere.weird.setting\",\n+                content: {\n+                    setting1: true,\n+                    setting2: false,\n+                }\n+            }\n+        ],\n+                \n+        // updates about publically published users' data\n+        \"public_user_data\": [\n+            {\n+                \"event_id\": \"$14qwtyeufet783:matrix.org\",\n+                \"sender\": \"@matthew:tp.mu\"\n+                type: \"m.profile.avatar_url\",\n+                content: {\n+                    avatar_url: \"mxc://matrix.org/QG1hdHRoZXc6d\",\n+                }\n+            },\n+            {\n+                \"event_id\": \"$14qwtyeufet784:matrix.org\",\n+                \"sender\": \"@matthew:tp.mu\"\n+                type: \"m.profile.display_name\",\n+                content: {\n+                    display_name: \"Matthew\",\n+                }\n+            },\n+            {\n+                \"event_id\": \"$14qwtyeufet785:matrix.org\",\n+                \"sender\": \"@matthew:tp.mu\"\n+                type: \"m.presence\", // the global per-user presence as calculated serverside by aggregating the per-device presence data\n+                content: {\n+                    presence: \"idle\" // one of online/idle/offline\n+                    \"last_active\": 368200528, // when did the server last see proactive interaction from this user on any client.\n+                }\n+            },\n+        ],\n+        \n+        \"rooms\": [{       \n+            \"room_id\": \"!KrLWMLDnZAyTapqLWW:matrix.org\",\n+            \"limited\": true, // has the limit been exceeded for the number of events returned for this room? if so, the client should be aware that there's a gap in the event stream\n+            \"published\": true, // HS telling us that this room has been published in our aliases directory\n+         \n+            \"event_map\": {\n+                \"$1417731086506PgoVf:matrix.org\": {\n+                    \"type\": \"m.room.member\",\n+                    \"content\": {\n+                        \"membership\": \"join\"\n+                    },\n+                    \"origin_server_ts\": 1417731086795,",
    "path": "drafts/cs-v2-http-api.rst",
    "position": 233,
    "original_position": 215,
    "commit_id": "7b7d124f24272aeaa19444994e8e3d57cb353580",
    "original_commit_id": "bc087585232627c1354b4af694e990c02d78365a",
    "user": {
      "login": "NegativeMjark",
      "id": 904009,
      "avatar_url": "https://avatars.githubusercontent.com/u/904009?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/NegativeMjark",
      "html_url": "https://github.com/NegativeMjark",
      "followers_url": "https://api.github.com/users/NegativeMjark/followers",
      "following_url": "https://api.github.com/users/NegativeMjark/following{/other_user}",
      "gists_url": "https://api.github.com/users/NegativeMjark/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/NegativeMjark/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/NegativeMjark/subscriptions",
      "organizations_url": "https://api.github.com/users/NegativeMjark/orgs",
      "repos_url": "https://api.github.com/users/NegativeMjark/repos",
      "events_url": "https://api.github.com/users/NegativeMjark/events{/privacy}",
      "received_events_url": "https://api.github.com/users/NegativeMjark/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "The example events should include some sort of ordering key to indicate where in the timeline they appear. This may need to be part of unsigned since the ordering key will be different on different home servers.",
    "created_at": "2015-01-23T15:08:54Z",
    "updated_at": "2015-09-11T15:37:21Z",
    "html_url": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23454707",
    "pull_request_url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23454707"
      },
      "html": {
        "href": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23454707"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6"
      }
    }
  },
  {
    "url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23460128",
    "id": 23460128,
    "diff_hunk": "@@ -0,0 +1,553 @@\n+Client-Server v2 HTTP API Draft\n+===============================\n+\n+Filter API\n+----------\n+\n+The intersection of the parameters given defines the filter.  Unions of filters\n+can be achieved by querying multiple filters in parallel.\n+\n+XXX: Filters describe both what data to query and how to present it, so could\n+perhaps be better described as 'queries' or even 'subscriptions'?\n+\n+XXX: Is this actually sensible - should we instead have ordering & pagination &\n+limits etc provided per-query rather than lost in the filter?  Or you provide the\n+defaults in the filter definition, and then clobber them with query params.\n+\n+You can define a reusable filter with the below POST API.  The resulting filter_id\n+can then be passed to methods which can be filter.\n+\n+You can only create filters for your own user (filters are namespaced per user\n+as they are defined per-user data, like profiles etc)\n+\n+TODO: excluding filters (e.g. filter out \"org.matrix.neb.*\")\n+\n+XXX: how do we transition between non-coalesced pagination and coalesced pagination for related_to/updates\n+\n+::\n+\n+    POST /user/{userId}/filter\n+\n+.. code:: javascript    \n+    \n+    {\n+        // selectors: (bluntly selecting on the unencrypted fields)\n+        types: [ \"m.*\", \"net.arasphere.*\" ],    // default: all\n+        // N.B. types can be used to filter out presence and server-generated events (e.g. m.profile), but see *_user_data below\n+        not_types: [ \"m.presence\" ],            // default: none\n+        rooms: [ \"!83wy7whi:matrix.org\" ],      // default: all (may be aliases or IDs. wildcards supported)\n+        not_rooms: [],\n+        senders: [ \"@matthew:matrix.org\" ],  // default: all (e.g. for narrowing down presence, and stalker mode. wildcards supported)\n+        not_senders: [],\n+        \n+        public_user_data: true,  // include events describing public user data (as we might not know their types) - default: true\n+        private_user_data: true, // include events describing private user data (as we might not know their types) - default: true\n+        // XXX: How do these interact with specific type/non_type selectors prioritywise?\n+                \n+        // parameters\n+        \n+        // 'format' gives the desired shape of the response\n+        //   federation = include the federation layer as well as the raw content of events.\n+        //   events = the plain events\n+        format: \"federation\",\n+        \n+        // select specific specific fields of the event to be returned.\n+        // N.B. you cannot guaranteeing filter content fields as they may be encrypted.\n+        // e.g. selecting just event_id could be useful for doing server-side\n+        // sorting/pagination/threading\n+        select: [ \"event_id\", \"origin_server_ts\", \"thread_id\", \"content\", \"content.body\" ], \n+        \n+        // include bundled child-event updates (default false) // V2.0\n+        bundle_updates: true,\n+        \n+        // include bundled related events: // V2.1\n+        bundle_relates_to: [\n+            {\n+                relationship: \"in_reply_to\",\n+                // As this is an optimisation to avoid having to explicitly select/paginate the\n+                // related messages per-message, we have to include a limit here as if we were\n+                // actually executing the query per-message for the initial result set.\n+                // Limit gives the number of related events to bundle; the bundled events return batch tokens\n+                // to let you seperately paginate on them.\n+                limit: 10, // maximum number of related events to bundle in the results of this filtered result set.\n+                ancestors: true, // include all ancestors (default: true)\n+                descendents: true, // include all descendents (default: true)\n+                \n+                <recursively include a filter definition here for the subset of events>\n+                // need to support a sort criteria which reflects the linearised ordering of the relation graph\n+            },\n+        ],\n+                \n+        // XXX: we may also want room_sort to specify the order of rooms returned by /sync,\n+        // as well as pagination for rooms returned by /sync...\n+    }\n+\n+Returns ``200 OK``::\n+    \n+    {\n+        \"filter_id\": \"583e98c2d983\"\n+    }\n+\n+\n+\"Sync API\" (was Event Stream API / Global initial sync API)\n+-----------------------------------------------------------\n+\n+There is no difference between an incremental initial sync of events and polling for updates on the eventstream.  They both transfer a delta of events from the server to the client, and both deltas need to be capped to avoid DoSing the client if too much time has elapsed between syncs.  Initial sync is thus a capped incremental delta of events relative to clean client-side state.\n+\n+Therefore we propose combining them into a single /sync API.  It's important to note that we should not design out server->client pushed event updates - the data returned by /sync polling should also be suitable for pushing if available (with suitable gapping/capping to avoid DoSing the client).  XXX: do this!\n+\n+``GET /sync``\n+\n+TODO: https://matrix.org/jira/browse/SYN-168\n+    /initialSync should return the actual m.room.member invite, not random keys from it\n+\n+GET parameters::\n+\n+    limit: maximum number of events per room to return.  If this limit is exceeded and gap is true:\n+            1. the server must flag the gap in the response (to avoid ambiguity between hitting the limit and exceeding the limit)\n+            2. the client must either throw away older timeline information or model a 'gap' in the timeline\n+            3. the server must include the full delta of state keys since the last sync, but will truncate the timeline delta.\n+           If this limit is exceeded and gap is false:\n+            1. we just send through the next batch of events in the next call to /sync, without any gapping.\n+           \n+    gap: boolean - should we drop events and do a non-delta sync for rooms whose limit is exceeded.  default: true.\n+\n+    // server-side sorting, so we can paginate events serverside on a thin client.\n+    // N.B. we can only order by unencrypted fields.\n+    // N.B. clients will need to handle out-of-order messages intelligently\n+    // N.B. subset of things you're allowed to sort by may be arbitrarily\n+    // restricted by the server impl (XXX: capabilities?)\n+    // Servers MUST support the \"timeline\" ordering - which is linearised logical chronological ordering.\n+    // N.B. This only takes effect when paginating, and is ignored for streaming data, and can only be specified once per filter.\n+    //\n+    // the sort order of messages in the room, *only honoured during an initial sync*. default: \"timeline,asc\". may appear multiple times\n+    // subsequent calls to /sync will always return event updates in timeline order (thanks to causality)\n+    // the batch tokens per-room are dependent on the sort order and cannot be mixed between different uses of the same filter.\n+    // the use case here is to start paginating a room sorted by not-timeline (e.g. by sender id - e.g. mail client use case)\n+    sort: fieldname, direction (e.g. \"sender,asc\",).\n+    \n+    // XXX: this needs to be made prettier.  you can't be a boolean because normal server behaviour allows small misorderings.\n+    // This this is an optimisation to allow thin clients to save bandwidth and not see out-of-order events which they can't\n+    // do anything useful with.  However, small races should be allowed.\n+    // v2.1\n+    // exclude_out_of_order_events_older_than: 10000 // ignore misorderings worse than 10s\n+    \n+    since: <batch token> to request an incremental delta since the specified batch token\n+        We call this 'since' rather than 'from' because it's not for pagination but a delta.\n+        The specified batch token would be taken from the most recent sync request that completed for this filter.\n+    timeout: maximum time to poll (in milliseconds) before returning this request. Only meaningful if performing an incremental sync (i.e. `since` is set)\n+        \n+    set_presence: \"offline\" // optional parameter to tell the server not to interpret this request as a client (device) as coming online (and as a convenience method for overriding presence state in general - e.g. setting straight to \"idle\" rather than having to PUT to /users/{userId}/devices/{deviceId}/presence.  It's meaningless to set \"online\" as that's the default behaviour on the server.)\n+        \n+    backfill: true/false (default true): do we want to pull in state from federation if we have less than <limit> events available for a room?\n+    \n+    filter: <filter_id> // filters can change between requests, to allow us to narrow down a global initial sync to a given room or similar use cases.\n+    // filter overrides (useful for changing filters between requests)\n+    filter_type: wildcard event type match e.g. \"m.*\", \"m.presence\": default, all.  may appear multiple times.\n+    filter_room: wildcard room id/name match e.g. \"!83wy7whi:matrix.org\": default, all.  may appear multiple times.\n+    filter_sender: wildcard sender id match e.g. \"@matthew:matrix.org\": default, all.  may appear multiple times.\n+    filter_event_id: event id to match e.g. \"$192318719:matrix.org\" // default, all: may appear multiple times\n+    filter_format: \"federation\" or \"events\"\n+    filter_select: event fields to return: default, all.  may appear multiple times\n+    filter_bundle_updates: true/false: default, false. bundle updates in events.\n+    // we deliberately don't specify filter_bundle_relates_to, as it's too hard to serialise into querystring params\n+\n+Returns ``200 OK``:\n+\n+.. code:: javascript\n+    \n+    {\n+        \"next_batch\": \"s72595_4483_1934\", // the batch token we pass to /sync's since param\n+        \n+        // updates about our own user data\n+        \"private_user_data\": [\n+            {\n+                \"event_id\": \"$15zxhijvwguye:matrix.org\",\n+                \"sender\": \"@matthew:tp.mu\"\n+                type: \"net.arasphere.weird.setting\",\n+                content: {\n+                    setting1: true,\n+                    setting2: false,\n+                }\n+            }\n+        ],",
    "path": "drafts/cs-v2-http-api.rst",
    "position": 191,
    "original_position": 173,
    "commit_id": "7b7d124f24272aeaa19444994e8e3d57cb353580",
    "original_commit_id": "bc087585232627c1354b4af694e990c02d78365a",
    "user": {
      "login": "NegativeMjark",
      "id": 904009,
      "avatar_url": "https://avatars.githubusercontent.com/u/904009?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/NegativeMjark",
      "html_url": "https://github.com/NegativeMjark",
      "followers_url": "https://api.github.com/users/NegativeMjark/followers",
      "following_url": "https://api.github.com/users/NegativeMjark/following{/other_user}",
      "gists_url": "https://api.github.com/users/NegativeMjark/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/NegativeMjark/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/NegativeMjark/subscriptions",
      "organizations_url": "https://api.github.com/users/NegativeMjark/orgs",
      "repos_url": "https://api.github.com/users/NegativeMjark/repos",
      "events_url": "https://api.github.com/users/NegativeMjark/events{/privacy}",
      "received_events_url": "https://api.github.com/users/NegativeMjark/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Should this be a \"batch\" as well? Does a limit apply to the private_user_data?",
    "created_at": "2015-01-23T16:19:09Z",
    "updated_at": "2015-09-11T15:37:21Z",
    "html_url": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23460128",
    "pull_request_url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23460128"
      },
      "html": {
        "href": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23460128"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6"
      }
    }
  },
  {
    "url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23461470",
    "id": 23461470,
    "diff_hunk": "@@ -0,0 +1,553 @@\n+Client-Server v2 HTTP API Draft\n+===============================\n+\n+Filter API\n+----------\n+\n+The intersection of the parameters given defines the filter.  Unions of filters\n+can be achieved by querying multiple filters in parallel.\n+\n+XXX: Filters describe both what data to query and how to present it, so could\n+perhaps be better described as 'queries' or even 'subscriptions'?\n+\n+XXX: Is this actually sensible - should we instead have ordering & pagination &\n+limits etc provided per-query rather than lost in the filter?  Or you provide the\n+defaults in the filter definition, and then clobber them with query params.\n+\n+You can define a reusable filter with the below POST API.  The resulting filter_id\n+can then be passed to methods which can be filter.\n+\n+You can only create filters for your own user (filters are namespaced per user\n+as they are defined per-user data, like profiles etc)\n+\n+TODO: excluding filters (e.g. filter out \"org.matrix.neb.*\")\n+\n+XXX: how do we transition between non-coalesced pagination and coalesced pagination for related_to/updates\n+\n+::\n+\n+    POST /user/{userId}/filter\n+\n+.. code:: javascript    \n+    \n+    {\n+        // selectors: (bluntly selecting on the unencrypted fields)\n+        types: [ \"m.*\", \"net.arasphere.*\" ],    // default: all\n+        // N.B. types can be used to filter out presence and server-generated events (e.g. m.profile), but see *_user_data below\n+        not_types: [ \"m.presence\" ],            // default: none\n+        rooms: [ \"!83wy7whi:matrix.org\" ],      // default: all (may be aliases or IDs. wildcards supported)\n+        not_rooms: [],\n+        senders: [ \"@matthew:matrix.org\" ],  // default: all (e.g. for narrowing down presence, and stalker mode. wildcards supported)\n+        not_senders: [],\n+        \n+        public_user_data: true,  // include events describing public user data (as we might not know their types) - default: true\n+        private_user_data: true, // include events describing private user data (as we might not know their types) - default: true\n+        // XXX: How do these interact with specific type/non_type selectors prioritywise?\n+                \n+        // parameters\n+        \n+        // 'format' gives the desired shape of the response\n+        //   federation = include the federation layer as well as the raw content of events.\n+        //   events = the plain events\n+        format: \"federation\",\n+        \n+        // select specific specific fields of the event to be returned.\n+        // N.B. you cannot guaranteeing filter content fields as they may be encrypted.\n+        // e.g. selecting just event_id could be useful for doing server-side\n+        // sorting/pagination/threading\n+        select: [ \"event_id\", \"origin_server_ts\", \"thread_id\", \"content\", \"content.body\" ], \n+        \n+        // include bundled child-event updates (default false) // V2.0\n+        bundle_updates: true,\n+        \n+        // include bundled related events: // V2.1\n+        bundle_relates_to: [\n+            {\n+                relationship: \"in_reply_to\",\n+                // As this is an optimisation to avoid having to explicitly select/paginate the\n+                // related messages per-message, we have to include a limit here as if we were\n+                // actually executing the query per-message for the initial result set.\n+                // Limit gives the number of related events to bundle; the bundled events return batch tokens\n+                // to let you seperately paginate on them.\n+                limit: 10, // maximum number of related events to bundle in the results of this filtered result set.\n+                ancestors: true, // include all ancestors (default: true)\n+                descendents: true, // include all descendents (default: true)\n+                \n+                <recursively include a filter definition here for the subset of events>\n+                // need to support a sort criteria which reflects the linearised ordering of the relation graph\n+            },\n+        ],\n+                \n+        // XXX: we may also want room_sort to specify the order of rooms returned by /sync,\n+        // as well as pagination for rooms returned by /sync...\n+    }\n+\n+Returns ``200 OK``::\n+    \n+    {\n+        \"filter_id\": \"583e98c2d983\"\n+    }\n+\n+\n+\"Sync API\" (was Event Stream API / Global initial sync API)\n+-----------------------------------------------------------\n+\n+There is no difference between an incremental initial sync of events and polling for updates on the eventstream.  They both transfer a delta of events from the server to the client, and both deltas need to be capped to avoid DoSing the client if too much time has elapsed between syncs.  Initial sync is thus a capped incremental delta of events relative to clean client-side state.\n+\n+Therefore we propose combining them into a single /sync API.  It's important to note that we should not design out server->client pushed event updates - the data returned by /sync polling should also be suitable for pushing if available (with suitable gapping/capping to avoid DoSing the client).  XXX: do this!\n+\n+``GET /sync``\n+\n+TODO: https://matrix.org/jira/browse/SYN-168\n+    /initialSync should return the actual m.room.member invite, not random keys from it\n+\n+GET parameters::\n+\n+    limit: maximum number of events per room to return.  If this limit is exceeded and gap is true:\n+            1. the server must flag the gap in the response (to avoid ambiguity between hitting the limit and exceeding the limit)\n+            2. the client must either throw away older timeline information or model a 'gap' in the timeline\n+            3. the server must include the full delta of state keys since the last sync, but will truncate the timeline delta.\n+           If this limit is exceeded and gap is false:\n+            1. we just send through the next batch of events in the next call to /sync, without any gapping.\n+           \n+    gap: boolean - should we drop events and do a non-delta sync for rooms whose limit is exceeded.  default: true.\n+\n+    // server-side sorting, so we can paginate events serverside on a thin client.\n+    // N.B. we can only order by unencrypted fields.\n+    // N.B. clients will need to handle out-of-order messages intelligently\n+    // N.B. subset of things you're allowed to sort by may be arbitrarily\n+    // restricted by the server impl (XXX: capabilities?)\n+    // Servers MUST support the \"timeline\" ordering - which is linearised logical chronological ordering.\n+    // N.B. This only takes effect when paginating, and is ignored for streaming data, and can only be specified once per filter.\n+    //\n+    // the sort order of messages in the room, *only honoured during an initial sync*. default: \"timeline,asc\". may appear multiple times\n+    // subsequent calls to /sync will always return event updates in timeline order (thanks to causality)\n+    // the batch tokens per-room are dependent on the sort order and cannot be mixed between different uses of the same filter.\n+    // the use case here is to start paginating a room sorted by not-timeline (e.g. by sender id - e.g. mail client use case)\n+    sort: fieldname, direction (e.g. \"sender,asc\",).\n+    \n+    // XXX: this needs to be made prettier.  you can't be a boolean because normal server behaviour allows small misorderings.\n+    // This this is an optimisation to allow thin clients to save bandwidth and not see out-of-order events which they can't\n+    // do anything useful with.  However, small races should be allowed.\n+    // v2.1\n+    // exclude_out_of_order_events_older_than: 10000 // ignore misorderings worse than 10s\n+    \n+    since: <batch token> to request an incremental delta since the specified batch token\n+        We call this 'since' rather than 'from' because it's not for pagination but a delta.\n+        The specified batch token would be taken from the most recent sync request that completed for this filter.\n+    timeout: maximum time to poll (in milliseconds) before returning this request. Only meaningful if performing an incremental sync (i.e. `since` is set)\n+        \n+    set_presence: \"offline\" // optional parameter to tell the server not to interpret this request as a client (device) as coming online (and as a convenience method for overriding presence state in general - e.g. setting straight to \"idle\" rather than having to PUT to /users/{userId}/devices/{deviceId}/presence.  It's meaningless to set \"online\" as that's the default behaviour on the server.)\n+        \n+    backfill: true/false (default true): do we want to pull in state from federation if we have less than <limit> events available for a room?\n+    \n+    filter: <filter_id> // filters can change between requests, to allow us to narrow down a global initial sync to a given room or similar use cases.\n+    // filter overrides (useful for changing filters between requests)\n+    filter_type: wildcard event type match e.g. \"m.*\", \"m.presence\": default, all.  may appear multiple times.\n+    filter_room: wildcard room id/name match e.g. \"!83wy7whi:matrix.org\": default, all.  may appear multiple times.\n+    filter_sender: wildcard sender id match e.g. \"@matthew:matrix.org\": default, all.  may appear multiple times.\n+    filter_event_id: event id to match e.g. \"$192318719:matrix.org\" // default, all: may appear multiple times\n+    filter_format: \"federation\" or \"events\"\n+    filter_select: event fields to return: default, all.  may appear multiple times\n+    filter_bundle_updates: true/false: default, false. bundle updates in events.\n+    // we deliberately don't specify filter_bundle_relates_to, as it's too hard to serialise into querystring params\n+\n+Returns ``200 OK``:\n+\n+.. code:: javascript\n+    \n+    {\n+        \"next_batch\": \"s72595_4483_1934\", // the batch token we pass to /sync's since param\n+        \n+        // updates about our own user data\n+        \"private_user_data\": [\n+            {\n+                \"event_id\": \"$15zxhijvwguye:matrix.org\",\n+                \"sender\": \"@matthew:tp.mu\"\n+                type: \"net.arasphere.weird.setting\",\n+                content: {\n+                    setting1: true,\n+                    setting2: false,\n+                }\n+            }\n+        ],\n+                \n+        // updates about publically published users' data\n+        \"public_user_data\": [\n+            {\n+                \"event_id\": \"$14qwtyeufet783:matrix.org\",\n+                \"sender\": \"@matthew:tp.mu\"\n+                type: \"m.profile.avatar_url\",\n+                content: {\n+                    avatar_url: \"mxc://matrix.org/QG1hdHRoZXc6d\",\n+                }\n+            },\n+            {\n+                \"event_id\": \"$14qwtyeufet784:matrix.org\",\n+                \"sender\": \"@matthew:tp.mu\"\n+                type: \"m.profile.display_name\",\n+                content: {\n+                    display_name: \"Matthew\",\n+                }\n+            },\n+            {\n+                \"event_id\": \"$14qwtyeufet785:matrix.org\",\n+                \"sender\": \"@matthew:tp.mu\"\n+                type: \"m.presence\", // the global per-user presence as calculated serverside by aggregating the per-device presence data\n+                content: {\n+                    presence: \"idle\" // one of online/idle/offline\n+                    \"last_active\": 368200528, // when did the server last see proactive interaction from this user on any client.\n+                }\n+            },\n+        ],\n+        \n+        \"rooms\": [{       \n+            \"room_id\": \"!KrLWMLDnZAyTapqLWW:matrix.org\",\n+            \"limited\": true, // has the limit been exceeded for the number of events returned for this room? if so, the client should be aware that there's a gap in the event stream\n+            \"published\": true, // HS telling us that this room has been published in our aliases directory\n+         \n+            \"event_map\": {\n+                \"$1417731086506PgoVf:matrix.org\": {\n+                    \"type\": \"m.room.member\",\n+                    \"content\": {\n+                        \"membership\": \"join\"\n+                    },\n+                    \"origin_server_ts\": 1417731086795,\n+                    \"state_key\": \"@matthew:matrix.org\",\n+                    \"sender\": \"@matthew:matrix.org\"    \n+                },\n+        \n+                \"$13275681auxsabj:matrix.org\": {\n+                    \"type\": \"m.room.member.profile\",\n+                    content: {\n+                        \"avatar_url\": \"mxc://matrix.org/QG1hdHRoZXc6d\",\n+                        \"displayname\": \"Matthew\",\n+                    },\n+                    prev_content: {\n+                        \"avatar_url\": \"mxc://matrix.org/QG1hdHRoZXc6d\",\n+                        \"displayname\": \"Arathorn\",\n+                    },\n+                    \"origin_server_ts\": 1417731086796,\n+                    \"state_key\": \"@matthew:matrix.org\",\n+                    \"sender\": \"@matthew:matrix.org\"    \n+                },\n+\n+                \"$15e789t23987:matrix.org\": {\n+                    \"type\": \"m.room.message\",\n+                    \"unsigned\": {\n+                        \"age\": \"124524\",\n+                        \"txn_id\": \"1234\", // the transaction ID that the client specified in /send/{event_type}\n+                    },\n+                    content: {\n+                        \"body\": \"I am a fish\",\n+                        \"msgtype\": \"m.text\",\n+                    },\n+                    \"origin_server_ts\": 1417731086797,\n+                    \"sender\": \"@matthew:matrix.org\"    \n+                },\n+            },\n+        \n+            // \"membership\": \"join\",  // this now gets removed as redundant with state object, likewise invite keys (i.e. \"invitee\")\n+            \"events\": { // rename messages to events as this is a list of all events, not just messages (non-state events).\n+                        // gives a list of events, limited to $limit in length\n+                \"batch\": [\n+                    \"$1417731086506PgoVf:matrix.org\",\n+                    \"$13275681auxsabj:matrix.org\",\n+                    \"$15e789t23987:matrix.org\", ...\n+                ],\n+                \n+                // We don't have a next_batch because if we want to stream forwards we use\n+                // GET /sync?since=batch&filter_room=!KrLWMLDnZAyTapqLWW:matrix.org\n+                \n+                \"prev_batch\": \"t67-41151_4483_1934\" // for scrollback.\n+                // N.B. if you use prev_batch to scroll backwards you will receive events you already saw\n+                // if you have been calling /sync multiple times.  This is only useful for really thin clients.\n+                // If the client is tracking client-side history, then they should only store the prev_batch if\n+                // `limited` is true.\n+            },\n+\n+            \"state\": [\n+                \"$1417731086506PgoVf:matrix.org\"\n+                \"$13275681auxsabj:matrix.org\", ...\n+            ],",
    "path": "drafts/cs-v2-http-api.rst",
    "position": 290,
    "original_position": 272,
    "commit_id": "7b7d124f24272aeaa19444994e8e3d57cb353580",
    "original_commit_id": "bc087585232627c1354b4af694e990c02d78365a",
    "user": {
      "login": "NegativeMjark",
      "id": 904009,
      "avatar_url": "https://avatars.githubusercontent.com/u/904009?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/NegativeMjark",
      "html_url": "https://github.com/NegativeMjark",
      "followers_url": "https://api.github.com/users/NegativeMjark/followers",
      "following_url": "https://api.github.com/users/NegativeMjark/following{/other_user}",
      "gists_url": "https://api.github.com/users/NegativeMjark/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/NegativeMjark/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/NegativeMjark/subscriptions",
      "organizations_url": "https://api.github.com/users/NegativeMjark/orgs",
      "repos_url": "https://api.github.com/users/NegativeMjark/repos",
      "events_url": "https://api.github.com/users/NegativeMjark/events{/privacy}",
      "received_events_url": "https://api.github.com/users/NegativeMjark/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Would it make sense to group the state into a dict of  {\"state_type\": {\"state_key\": \"event_id\"}} to make it easier for clients to grab specific types of state events?",
    "created_at": "2015-01-23T16:34:39Z",
    "updated_at": "2015-09-11T15:37:21Z",
    "html_url": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23461470",
    "pull_request_url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23461470"
      },
      "html": {
        "href": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23461470"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6"
      }
    }
  },
  {
    "url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23463758",
    "id": 23463758,
    "diff_hunk": "@@ -0,0 +1,553 @@\n+Client-Server v2 HTTP API Draft\n+===============================\n+\n+Filter API\n+----------\n+\n+The intersection of the parameters given defines the filter.  Unions of filters\n+can be achieved by querying multiple filters in parallel.\n+\n+XXX: Filters describe both what data to query and how to present it, so could\n+perhaps be better described as 'queries' or even 'subscriptions'?\n+\n+XXX: Is this actually sensible - should we instead have ordering & pagination &\n+limits etc provided per-query rather than lost in the filter?  Or you provide the\n+defaults in the filter definition, and then clobber them with query params.\n+\n+You can define a reusable filter with the below POST API.  The resulting filter_id\n+can then be passed to methods which can be filter.\n+\n+You can only create filters for your own user (filters are namespaced per user\n+as they are defined per-user data, like profiles etc)\n+\n+TODO: excluding filters (e.g. filter out \"org.matrix.neb.*\")\n+\n+XXX: how do we transition between non-coalesced pagination and coalesced pagination for related_to/updates\n+\n+::\n+\n+    POST /user/{userId}/filter\n+\n+.. code:: javascript    \n+    \n+    {\n+        // selectors: (bluntly selecting on the unencrypted fields)\n+        types: [ \"m.*\", \"net.arasphere.*\" ],    // default: all\n+        // N.B. types can be used to filter out presence and server-generated events (e.g. m.profile), but see *_user_data below\n+        not_types: [ \"m.presence\" ],            // default: none\n+        rooms: [ \"!83wy7whi:matrix.org\" ],      // default: all (may be aliases or IDs. wildcards supported)\n+        not_rooms: [],\n+        senders: [ \"@matthew:matrix.org\" ],  // default: all (e.g. for narrowing down presence, and stalker mode. wildcards supported)\n+        not_senders: [],\n+        \n+        public_user_data: true,  // include events describing public user data (as we might not know their types) - default: true\n+        private_user_data: true, // include events describing private user data (as we might not know their types) - default: true\n+        // XXX: How do these interact with specific type/non_type selectors prioritywise?\n+                \n+        // parameters\n+        \n+        // 'format' gives the desired shape of the response\n+        //   federation = include the federation layer as well as the raw content of events.\n+        //   events = the plain events\n+        format: \"federation\",\n+        \n+        // select specific specific fields of the event to be returned.\n+        // N.B. you cannot guaranteeing filter content fields as they may be encrypted.\n+        // e.g. selecting just event_id could be useful for doing server-side\n+        // sorting/pagination/threading\n+        select: [ \"event_id\", \"origin_server_ts\", \"thread_id\", \"content\", \"content.body\" ], \n+        \n+        // include bundled child-event updates (default false) // V2.0\n+        bundle_updates: true,\n+        \n+        // include bundled related events: // V2.1\n+        bundle_relates_to: [\n+            {\n+                relationship: \"in_reply_to\",\n+                // As this is an optimisation to avoid having to explicitly select/paginate the\n+                // related messages per-message, we have to include a limit here as if we were\n+                // actually executing the query per-message for the initial result set.\n+                // Limit gives the number of related events to bundle; the bundled events return batch tokens\n+                // to let you seperately paginate on them.\n+                limit: 10, // maximum number of related events to bundle in the results of this filtered result set.\n+                ancestors: true, // include all ancestors (default: true)\n+                descendents: true, // include all descendents (default: true)\n+                \n+                <recursively include a filter definition here for the subset of events>\n+                // need to support a sort criteria which reflects the linearised ordering of the relation graph\n+            },\n+        ],\n+                \n+        // XXX: we may also want room_sort to specify the order of rooms returned by /sync,\n+        // as well as pagination for rooms returned by /sync...\n+    }\n+\n+Returns ``200 OK``::\n+    \n+    {\n+        \"filter_id\": \"583e98c2d983\"\n+    }\n+\n+\n+\"Sync API\" (was Event Stream API / Global initial sync API)\n+-----------------------------------------------------------\n+\n+There is no difference between an incremental initial sync of events and polling for updates on the eventstream.  They both transfer a delta of events from the server to the client, and both deltas need to be capped to avoid DoSing the client if too much time has elapsed between syncs.  Initial sync is thus a capped incremental delta of events relative to clean client-side state.\n+\n+Therefore we propose combining them into a single /sync API.  It's important to note that we should not design out server->client pushed event updates - the data returned by /sync polling should also be suitable for pushing if available (with suitable gapping/capping to avoid DoSing the client).  XXX: do this!\n+\n+``GET /sync``\n+\n+TODO: https://matrix.org/jira/browse/SYN-168\n+    /initialSync should return the actual m.room.member invite, not random keys from it\n+\n+GET parameters::\n+\n+    limit: maximum number of events per room to return.  If this limit is exceeded and gap is true:\n+            1. the server must flag the gap in the response (to avoid ambiguity between hitting the limit and exceeding the limit)\n+            2. the client must either throw away older timeline information or model a 'gap' in the timeline\n+            3. the server must include the full delta of state keys since the last sync, but will truncate the timeline delta.\n+           If this limit is exceeded and gap is false:\n+            1. we just send through the next batch of events in the next call to /sync, without any gapping.\n+           \n+    gap: boolean - should we drop events and do a non-delta sync for rooms whose limit is exceeded.  default: true.\n+\n+    // server-side sorting, so we can paginate events serverside on a thin client.\n+    // N.B. we can only order by unencrypted fields.\n+    // N.B. clients will need to handle out-of-order messages intelligently\n+    // N.B. subset of things you're allowed to sort by may be arbitrarily\n+    // restricted by the server impl (XXX: capabilities?)\n+    // Servers MUST support the \"timeline\" ordering - which is linearised logical chronological ordering.\n+    // N.B. This only takes effect when paginating, and is ignored for streaming data, and can only be specified once per filter.\n+    //\n+    // the sort order of messages in the room, *only honoured during an initial sync*. default: \"timeline,asc\". may appear multiple times\n+    // subsequent calls to /sync will always return event updates in timeline order (thanks to causality)\n+    // the batch tokens per-room are dependent on the sort order and cannot be mixed between different uses of the same filter.\n+    // the use case here is to start paginating a room sorted by not-timeline (e.g. by sender id - e.g. mail client use case)\n+    sort: fieldname, direction (e.g. \"sender,asc\",).\n+    \n+    // XXX: this needs to be made prettier.  you can't be a boolean because normal server behaviour allows small misorderings.\n+    // This this is an optimisation to allow thin clients to save bandwidth and not see out-of-order events which they can't\n+    // do anything useful with.  However, small races should be allowed.\n+    // v2.1\n+    // exclude_out_of_order_events_older_than: 10000 // ignore misorderings worse than 10s\n+    \n+    since: <batch token> to request an incremental delta since the specified batch token\n+        We call this 'since' rather than 'from' because it's not for pagination but a delta.\n+        The specified batch token would be taken from the most recent sync request that completed for this filter.\n+    timeout: maximum time to poll (in milliseconds) before returning this request. Only meaningful if performing an incremental sync (i.e. `since` is set)\n+        \n+    set_presence: \"offline\" // optional parameter to tell the server not to interpret this request as a client (device) as coming online (and as a convenience method for overriding presence state in general - e.g. setting straight to \"idle\" rather than having to PUT to /users/{userId}/devices/{deviceId}/presence.  It's meaningless to set \"online\" as that's the default behaviour on the server.)\n+        \n+    backfill: true/false (default true): do we want to pull in state from federation if we have less than <limit> events available for a room?\n+    \n+    filter: <filter_id> // filters can change between requests, to allow us to narrow down a global initial sync to a given room or similar use cases.\n+    // filter overrides (useful for changing filters between requests)\n+    filter_type: wildcard event type match e.g. \"m.*\", \"m.presence\": default, all.  may appear multiple times.\n+    filter_room: wildcard room id/name match e.g. \"!83wy7whi:matrix.org\": default, all.  may appear multiple times.\n+    filter_sender: wildcard sender id match e.g. \"@matthew:matrix.org\": default, all.  may appear multiple times.\n+    filter_event_id: event id to match e.g. \"$192318719:matrix.org\" // default, all: may appear multiple times\n+    filter_format: \"federation\" or \"events\"\n+    filter_select: event fields to return: default, all.  may appear multiple times\n+    filter_bundle_updates: true/false: default, false. bundle updates in events.\n+    // we deliberately don't specify filter_bundle_relates_to, as it's too hard to serialise into querystring params\n+\n+Returns ``200 OK``:\n+\n+.. code:: javascript\n+    \n+    {\n+        \"next_batch\": \"s72595_4483_1934\", // the batch token we pass to /sync's since param\n+        \n+        // updates about our own user data\n+        \"private_user_data\": [\n+            {\n+                \"event_id\": \"$15zxhijvwguye:matrix.org\",\n+                \"sender\": \"@matthew:tp.mu\"\n+                type: \"net.arasphere.weird.setting\",\n+                content: {\n+                    setting1: true,\n+                    setting2: false,\n+                }\n+            }\n+        ],\n+                \n+        // updates about publically published users' data\n+        \"public_user_data\": [\n+            {\n+                \"event_id\": \"$14qwtyeufet783:matrix.org\",\n+                \"sender\": \"@matthew:tp.mu\"\n+                type: \"m.profile.avatar_url\",\n+                content: {\n+                    avatar_url: \"mxc://matrix.org/QG1hdHRoZXc6d\",\n+                }\n+            },\n+            {\n+                \"event_id\": \"$14qwtyeufet784:matrix.org\",\n+                \"sender\": \"@matthew:tp.mu\"\n+                type: \"m.profile.display_name\",\n+                content: {\n+                    display_name: \"Matthew\",\n+                }\n+            },\n+            {\n+                \"event_id\": \"$14qwtyeufet785:matrix.org\",\n+                \"sender\": \"@matthew:tp.mu\"\n+                type: \"m.presence\", // the global per-user presence as calculated serverside by aggregating the per-device presence data\n+                content: {\n+                    presence: \"idle\" // one of online/idle/offline\n+                    \"last_active\": 368200528, // when did the server last see proactive interaction from this user on any client.\n+                }\n+            },\n+        ],\n+        \n+        \"rooms\": [{       \n+            \"room_id\": \"!KrLWMLDnZAyTapqLWW:matrix.org\",\n+            \"limited\": true, // has the limit been exceeded for the number of events returned for this room? if so, the client should be aware that there's a gap in the event stream\n+            \"published\": true, // HS telling us that this room has been published in our aliases directory\n+         \n+            \"event_map\": {\n+                \"$1417731086506PgoVf:matrix.org\": {\n+                    \"type\": \"m.room.member\",\n+                    \"content\": {\n+                        \"membership\": \"join\"\n+                    },\n+                    \"origin_server_ts\": 1417731086795,\n+                    \"state_key\": \"@matthew:matrix.org\",\n+                    \"sender\": \"@matthew:matrix.org\"    \n+                },\n+        \n+                \"$13275681auxsabj:matrix.org\": {\n+                    \"type\": \"m.room.member.profile\",\n+                    content: {\n+                        \"avatar_url\": \"mxc://matrix.org/QG1hdHRoZXc6d\",\n+                        \"displayname\": \"Matthew\",\n+                    },\n+                    prev_content: {\n+                        \"avatar_url\": \"mxc://matrix.org/QG1hdHRoZXc6d\",\n+                        \"displayname\": \"Arathorn\",\n+                    },\n+                    \"origin_server_ts\": 1417731086796,\n+                    \"state_key\": \"@matthew:matrix.org\",\n+                    \"sender\": \"@matthew:matrix.org\"    \n+                },\n+\n+                \"$15e789t23987:matrix.org\": {\n+                    \"type\": \"m.room.message\",\n+                    \"unsigned\": {\n+                        \"age\": \"124524\",\n+                        \"txn_id\": \"1234\", // the transaction ID that the client specified in /send/{event_type}\n+                    },\n+                    content: {\n+                        \"body\": \"I am a fish\",\n+                        \"msgtype\": \"m.text\",\n+                    },\n+                    \"origin_server_ts\": 1417731086797,\n+                    \"sender\": \"@matthew:matrix.org\"    \n+                },\n+            },\n+        \n+            // \"membership\": \"join\",  // this now gets removed as redundant with state object, likewise invite keys (i.e. \"invitee\")\n+            \"events\": { // rename messages to events as this is a list of all events, not just messages (non-state events).\n+                        // gives a list of events, limited to $limit in length\n+                \"batch\": [\n+                    \"$1417731086506PgoVf:matrix.org\",\n+                    \"$13275681auxsabj:matrix.org\",\n+                    \"$15e789t23987:matrix.org\", ...\n+                ],\n+                \n+                // We don't have a next_batch because if we want to stream forwards we use\n+                // GET /sync?since=batch&filter_room=!KrLWMLDnZAyTapqLWW:matrix.org\n+                \n+                \"prev_batch\": \"t67-41151_4483_1934\" // for scrollback.\n+                // N.B. if you use prev_batch to scroll backwards you will receive events you already saw\n+                // if you have been calling /sync multiple times.  This is only useful for really thin clients.\n+                // If the client is tracking client-side history, then they should only store the prev_batch if\n+                // `limited` is true.\n+            },\n+\n+            \"state\": [\n+                \"$1417731086506PgoVf:matrix.org\"\n+                \"$13275681auxsabj:matrix.org\", ...\n+            ],",
    "path": "drafts/cs-v2-http-api.rst",
    "position": 290,
    "original_position": 272,
    "commit_id": "7b7d124f24272aeaa19444994e8e3d57cb353580",
    "original_commit_id": "bc087585232627c1354b4af694e990c02d78365a",
    "user": {
      "login": "Kegsay",
      "id": 7190048,
      "avatar_url": "https://avatars.githubusercontent.com/u/7190048?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Kegsay",
      "html_url": "https://github.com/Kegsay",
      "followers_url": "https://api.github.com/users/Kegsay/followers",
      "following_url": "https://api.github.com/users/Kegsay/following{/other_user}",
      "gists_url": "https://api.github.com/users/Kegsay/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Kegsay/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Kegsay/subscriptions",
      "organizations_url": "https://api.github.com/users/Kegsay/orgs",
      "repos_url": "https://api.github.com/users/Kegsay/repos",
      "events_url": "https://api.github.com/users/Kegsay/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Kegsay/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "> Would it make sense to group the state into a dict of {\"state_type\": {\"state_key\": \"event_id\"}} to make it easier for clients to grab specific types of state events?\r\n\r\nI don't think it would make it more convenient. By this point, clients have already specified what event types they want, and will be rapidly dumping this JSON into their own data structures, which provide methods for extracting state based on type/key tuple. We should support them by just giving an array of events, rather than forcing them to loop *two sets* of JSON keys to get at the precious precious event ID.",
    "created_at": "2015-01-23T17:05:21Z",
    "updated_at": "2015-09-11T15:37:21Z",
    "html_url": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23463758",
    "pull_request_url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23463758"
      },
      "html": {
        "href": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23463758"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6"
      }
    }
  },
  {
    "url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23464020",
    "id": 23464020,
    "diff_hunk": "@@ -0,0 +1,553 @@\n+Client-Server v2 HTTP API Draft\n+===============================\n+\n+Filter API\n+----------\n+\n+The intersection of the parameters given defines the filter.  Unions of filters\n+can be achieved by querying multiple filters in parallel.\n+\n+XXX: Filters describe both what data to query and how to present it, so could\n+perhaps be better described as 'queries' or even 'subscriptions'?\n+\n+XXX: Is this actually sensible - should we instead have ordering & pagination &\n+limits etc provided per-query rather than lost in the filter?  Or you provide the\n+defaults in the filter definition, and then clobber them with query params.\n+\n+You can define a reusable filter with the below POST API.  The resulting filter_id\n+can then be passed to methods which can be filter.\n+\n+You can only create filters for your own user (filters are namespaced per user\n+as they are defined per-user data, like profiles etc)\n+\n+TODO: excluding filters (e.g. filter out \"org.matrix.neb.*\")\n+\n+XXX: how do we transition between non-coalesced pagination and coalesced pagination for related_to/updates\n+\n+::\n+\n+    POST /user/{userId}/filter\n+\n+.. code:: javascript    \n+    \n+    {\n+        // selectors: (bluntly selecting on the unencrypted fields)\n+        types: [ \"m.*\", \"net.arasphere.*\" ],    // default: all\n+        // N.B. types can be used to filter out presence and server-generated events (e.g. m.profile), but see *_user_data below\n+        not_types: [ \"m.presence\" ],            // default: none\n+        rooms: [ \"!83wy7whi:matrix.org\" ],      // default: all (may be aliases or IDs. wildcards supported)\n+        not_rooms: [],\n+        senders: [ \"@matthew:matrix.org\" ],  // default: all (e.g. for narrowing down presence, and stalker mode. wildcards supported)\n+        not_senders: [],\n+        \n+        public_user_data: true,  // include events describing public user data (as we might not know their types) - default: true\n+        private_user_data: true, // include events describing private user data (as we might not know their types) - default: true\n+        // XXX: How do these interact with specific type/non_type selectors prioritywise?\n+                \n+        // parameters\n+        \n+        // 'format' gives the desired shape of the response\n+        //   federation = include the federation layer as well as the raw content of events.\n+        //   events = the plain events\n+        format: \"federation\",\n+        \n+        // select specific specific fields of the event to be returned.\n+        // N.B. you cannot guaranteeing filter content fields as they may be encrypted.\n+        // e.g. selecting just event_id could be useful for doing server-side\n+        // sorting/pagination/threading\n+        select: [ \"event_id\", \"origin_server_ts\", \"thread_id\", \"content\", \"content.body\" ], \n+        \n+        // include bundled child-event updates (default false) // V2.0\n+        bundle_updates: true,\n+        \n+        // include bundled related events: // V2.1\n+        bundle_relates_to: [\n+            {\n+                relationship: \"in_reply_to\",\n+                // As this is an optimisation to avoid having to explicitly select/paginate the\n+                // related messages per-message, we have to include a limit here as if we were\n+                // actually executing the query per-message for the initial result set.\n+                // Limit gives the number of related events to bundle; the bundled events return batch tokens\n+                // to let you seperately paginate on them.\n+                limit: 10, // maximum number of related events to bundle in the results of this filtered result set.\n+                ancestors: true, // include all ancestors (default: true)\n+                descendents: true, // include all descendents (default: true)\n+                \n+                <recursively include a filter definition here for the subset of events>\n+                // need to support a sort criteria which reflects the linearised ordering of the relation graph\n+            },\n+        ],\n+                \n+        // XXX: we may also want room_sort to specify the order of rooms returned by /sync,\n+        // as well as pagination for rooms returned by /sync...\n+    }\n+\n+Returns ``200 OK``::\n+    \n+    {\n+        \"filter_id\": \"583e98c2d983\"\n+    }\n+\n+\n+\"Sync API\" (was Event Stream API / Global initial sync API)\n+-----------------------------------------------------------\n+\n+There is no difference between an incremental initial sync of events and polling for updates on the eventstream.  They both transfer a delta of events from the server to the client, and both deltas need to be capped to avoid DoSing the client if too much time has elapsed between syncs.  Initial sync is thus a capped incremental delta of events relative to clean client-side state.\n+\n+Therefore we propose combining them into a single /sync API.  It's important to note that we should not design out server->client pushed event updates - the data returned by /sync polling should also be suitable for pushing if available (with suitable gapping/capping to avoid DoSing the client).  XXX: do this!\n+\n+``GET /sync``\n+\n+TODO: https://matrix.org/jira/browse/SYN-168\n+    /initialSync should return the actual m.room.member invite, not random keys from it\n+\n+GET parameters::\n+\n+    limit: maximum number of events per room to return.  If this limit is exceeded and gap is true:\n+            1. the server must flag the gap in the response (to avoid ambiguity between hitting the limit and exceeding the limit)\n+            2. the client must either throw away older timeline information or model a 'gap' in the timeline\n+            3. the server must include the full delta of state keys since the last sync, but will truncate the timeline delta.\n+           If this limit is exceeded and gap is false:\n+            1. we just send through the next batch of events in the next call to /sync, without any gapping.\n+           \n+    gap: boolean - should we drop events and do a non-delta sync for rooms whose limit is exceeded.  default: true.\n+\n+    // server-side sorting, so we can paginate events serverside on a thin client.\n+    // N.B. we can only order by unencrypted fields.\n+    // N.B. clients will need to handle out-of-order messages intelligently\n+    // N.B. subset of things you're allowed to sort by may be arbitrarily\n+    // restricted by the server impl (XXX: capabilities?)\n+    // Servers MUST support the \"timeline\" ordering - which is linearised logical chronological ordering.\n+    // N.B. This only takes effect when paginating, and is ignored for streaming data, and can only be specified once per filter.\n+    //\n+    // the sort order of messages in the room, *only honoured during an initial sync*. default: \"timeline,asc\". may appear multiple times\n+    // subsequent calls to /sync will always return event updates in timeline order (thanks to causality)\n+    // the batch tokens per-room are dependent on the sort order and cannot be mixed between different uses of the same filter.\n+    // the use case here is to start paginating a room sorted by not-timeline (e.g. by sender id - e.g. mail client use case)\n+    sort: fieldname, direction (e.g. \"sender,asc\",).\n+    \n+    // XXX: this needs to be made prettier.  you can't be a boolean because normal server behaviour allows small misorderings.\n+    // This this is an optimisation to allow thin clients to save bandwidth and not see out-of-order events which they can't\n+    // do anything useful with.  However, small races should be allowed.\n+    // v2.1\n+    // exclude_out_of_order_events_older_than: 10000 // ignore misorderings worse than 10s\n+    \n+    since: <batch token> to request an incremental delta since the specified batch token\n+        We call this 'since' rather than 'from' because it's not for pagination but a delta.\n+        The specified batch token would be taken from the most recent sync request that completed for this filter.\n+    timeout: maximum time to poll (in milliseconds) before returning this request. Only meaningful if performing an incremental sync (i.e. `since` is set)\n+        \n+    set_presence: \"offline\" // optional parameter to tell the server not to interpret this request as a client (device) as coming online (and as a convenience method for overriding presence state in general - e.g. setting straight to \"idle\" rather than having to PUT to /users/{userId}/devices/{deviceId}/presence.  It's meaningless to set \"online\" as that's the default behaviour on the server.)\n+        \n+    backfill: true/false (default true): do we want to pull in state from federation if we have less than <limit> events available for a room?\n+    \n+    filter: <filter_id> // filters can change between requests, to allow us to narrow down a global initial sync to a given room or similar use cases.\n+    // filter overrides (useful for changing filters between requests)\n+    filter_type: wildcard event type match e.g. \"m.*\", \"m.presence\": default, all.  may appear multiple times.\n+    filter_room: wildcard room id/name match e.g. \"!83wy7whi:matrix.org\": default, all.  may appear multiple times.\n+    filter_sender: wildcard sender id match e.g. \"@matthew:matrix.org\": default, all.  may appear multiple times.\n+    filter_event_id: event id to match e.g. \"$192318719:matrix.org\" // default, all: may appear multiple times\n+    filter_format: \"federation\" or \"events\"\n+    filter_select: event fields to return: default, all.  may appear multiple times\n+    filter_bundle_updates: true/false: default, false. bundle updates in events.\n+    // we deliberately don't specify filter_bundle_relates_to, as it's too hard to serialise into querystring params\n+\n+Returns ``200 OK``:\n+\n+.. code:: javascript\n+    \n+    {\n+        \"next_batch\": \"s72595_4483_1934\", // the batch token we pass to /sync's since param\n+        \n+        // updates about our own user data\n+        \"private_user_data\": [\n+            {\n+                \"event_id\": \"$15zxhijvwguye:matrix.org\",\n+                \"sender\": \"@matthew:tp.mu\"\n+                type: \"net.arasphere.weird.setting\",\n+                content: {\n+                    setting1: true,\n+                    setting2: false,\n+                }\n+            }\n+        ],\n+                \n+        // updates about publically published users' data\n+        \"public_user_data\": [\n+            {\n+                \"event_id\": \"$14qwtyeufet783:matrix.org\",\n+                \"sender\": \"@matthew:tp.mu\"\n+                type: \"m.profile.avatar_url\",\n+                content: {\n+                    avatar_url: \"mxc://matrix.org/QG1hdHRoZXc6d\",\n+                }\n+            },\n+            {\n+                \"event_id\": \"$14qwtyeufet784:matrix.org\",\n+                \"sender\": \"@matthew:tp.mu\"\n+                type: \"m.profile.display_name\",\n+                content: {\n+                    display_name: \"Matthew\",\n+                }\n+            },\n+            {\n+                \"event_id\": \"$14qwtyeufet785:matrix.org\",\n+                \"sender\": \"@matthew:tp.mu\"\n+                type: \"m.presence\", // the global per-user presence as calculated serverside by aggregating the per-device presence data\n+                content: {\n+                    presence: \"idle\" // one of online/idle/offline\n+                    \"last_active\": 368200528, // when did the server last see proactive interaction from this user on any client.\n+                }\n+            },\n+        ],\n+        \n+        \"rooms\": [{       \n+            \"room_id\": \"!KrLWMLDnZAyTapqLWW:matrix.org\",\n+            \"limited\": true, // has the limit been exceeded for the number of events returned for this room? if so, the client should be aware that there's a gap in the event stream\n+            \"published\": true, // HS telling us that this room has been published in our aliases directory\n+         \n+            \"event_map\": {\n+                \"$1417731086506PgoVf:matrix.org\": {\n+                    \"type\": \"m.room.member\",\n+                    \"content\": {\n+                        \"membership\": \"join\"\n+                    },\n+                    \"origin_server_ts\": 1417731086795,\n+                    \"state_key\": \"@matthew:matrix.org\",\n+                    \"sender\": \"@matthew:matrix.org\"    \n+                },\n+        \n+                \"$13275681auxsabj:matrix.org\": {\n+                    \"type\": \"m.room.member.profile\",\n+                    content: {\n+                        \"avatar_url\": \"mxc://matrix.org/QG1hdHRoZXc6d\",\n+                        \"displayname\": \"Matthew\",\n+                    },\n+                    prev_content: {\n+                        \"avatar_url\": \"mxc://matrix.org/QG1hdHRoZXc6d\",\n+                        \"displayname\": \"Arathorn\",\n+                    },\n+                    \"origin_server_ts\": 1417731086796,\n+                    \"state_key\": \"@matthew:matrix.org\",\n+                    \"sender\": \"@matthew:matrix.org\"    \n+                },\n+\n+                \"$15e789t23987:matrix.org\": {\n+                    \"type\": \"m.room.message\",\n+                    \"unsigned\": {\n+                        \"age\": \"124524\",\n+                        \"txn_id\": \"1234\", // the transaction ID that the client specified in /send/{event_type}\n+                    },\n+                    content: {\n+                        \"body\": \"I am a fish\",\n+                        \"msgtype\": \"m.text\",\n+                    },\n+                    \"origin_server_ts\": 1417731086797,\n+                    \"sender\": \"@matthew:matrix.org\"    \n+                },\n+            },\n+        \n+            // \"membership\": \"join\",  // this now gets removed as redundant with state object, likewise invite keys (i.e. \"invitee\")\n+            \"events\": { // rename messages to events as this is a list of all events, not just messages (non-state events).\n+                        // gives a list of events, limited to $limit in length\n+                \"batch\": [\n+                    \"$1417731086506PgoVf:matrix.org\",\n+                    \"$13275681auxsabj:matrix.org\",\n+                    \"$15e789t23987:matrix.org\", ...\n+                ],\n+                \n+                // We don't have a next_batch because if we want to stream forwards we use\n+                // GET /sync?since=batch&filter_room=!KrLWMLDnZAyTapqLWW:matrix.org\n+                \n+                \"prev_batch\": \"t67-41151_4483_1934\" // for scrollback.\n+                // N.B. if you use prev_batch to scroll backwards you will receive events you already saw\n+                // if you have been calling /sync multiple times.  This is only useful for really thin clients.\n+                // If the client is tracking client-side history, then they should only store the prev_batch if\n+                // `limited` is true.\n+            },\n+\n+            \"state\": [\n+                \"$1417731086506PgoVf:matrix.org\"\n+                \"$13275681auxsabj:matrix.org\", ...\n+            ],",
    "path": "drafts/cs-v2-http-api.rst",
    "position": 290,
    "original_position": 272,
    "commit_id": "7b7d124f24272aeaa19444994e8e3d57cb353580",
    "original_commit_id": "bc087585232627c1354b4af694e990c02d78365a",
    "user": {
      "login": "NegativeMjark",
      "id": 904009,
      "avatar_url": "https://avatars.githubusercontent.com/u/904009?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/NegativeMjark",
      "html_url": "https://github.com/NegativeMjark",
      "followers_url": "https://api.github.com/users/NegativeMjark/followers",
      "following_url": "https://api.github.com/users/NegativeMjark/following{/other_user}",
      "gists_url": "https://api.github.com/users/NegativeMjark/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/NegativeMjark/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/NegativeMjark/subscriptions",
      "organizations_url": "https://api.github.com/users/NegativeMjark/orgs",
      "repos_url": "https://api.github.com/users/NegativeMjark/repos",
      "events_url": "https://api.github.com/users/NegativeMjark/events{/privacy}",
      "received_events_url": "https://api.github.com/users/NegativeMjark/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I guess this makes more sense when state updates are actual events rather than event IDs. Since the client can use then use the state map directly. But if they have to map through the event_map to get that actual event they are going to have to do a load of processing anyway.",
    "created_at": "2015-01-23T17:09:05Z",
    "updated_at": "2015-09-11T15:37:21Z",
    "html_url": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23464020",
    "pull_request_url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23464020"
      },
      "html": {
        "href": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23464020"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6"
      }
    }
  },
  {
    "url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23466108",
    "id": 23466108,
    "diff_hunk": "@@ -0,0 +1,553 @@\n+Client-Server v2 HTTP API Draft\n+===============================\n+\n+Filter API\n+----------\n+\n+The intersection of the parameters given defines the filter.  Unions of filters\n+can be achieved by querying multiple filters in parallel.\n+\n+XXX: Filters describe both what data to query and how to present it, so could\n+perhaps be better described as 'queries' or even 'subscriptions'?\n+\n+XXX: Is this actually sensible - should we instead have ordering & pagination &\n+limits etc provided per-query rather than lost in the filter?  Or you provide the\n+defaults in the filter definition, and then clobber them with query params.\n+\n+You can define a reusable filter with the below POST API.  The resulting filter_id\n+can then be passed to methods which can be filter.\n+\n+You can only create filters for your own user (filters are namespaced per user\n+as they are defined per-user data, like profiles etc)\n+\n+TODO: excluding filters (e.g. filter out \"org.matrix.neb.*\")\n+\n+XXX: how do we transition between non-coalesced pagination and coalesced pagination for related_to/updates\n+\n+::\n+\n+    POST /user/{userId}/filter\n+\n+.. code:: javascript    \n+    \n+    {\n+        // selectors: (bluntly selecting on the unencrypted fields)\n+        types: [ \"m.*\", \"net.arasphere.*\" ],    // default: all\n+        // N.B. types can be used to filter out presence and server-generated events (e.g. m.profile), but see *_user_data below\n+        not_types: [ \"m.presence\" ],            // default: none\n+        rooms: [ \"!83wy7whi:matrix.org\" ],      // default: all (may be aliases or IDs. wildcards supported)\n+        not_rooms: [],\n+        senders: [ \"@matthew:matrix.org\" ],  // default: all (e.g. for narrowing down presence, and stalker mode. wildcards supported)\n+        not_senders: [],\n+        \n+        public_user_data: true,  // include events describing public user data (as we might not know their types) - default: true\n+        private_user_data: true, // include events describing private user data (as we might not know their types) - default: true\n+        // XXX: How do these interact with specific type/non_type selectors prioritywise?\n+                \n+        // parameters\n+        \n+        // 'format' gives the desired shape of the response\n+        //   federation = include the federation layer as well as the raw content of events.\n+        //   events = the plain events\n+        format: \"federation\",\n+        \n+        // select specific specific fields of the event to be returned.\n+        // N.B. you cannot guaranteeing filter content fields as they may be encrypted.\n+        // e.g. selecting just event_id could be useful for doing server-side\n+        // sorting/pagination/threading\n+        select: [ \"event_id\", \"origin_server_ts\", \"thread_id\", \"content\", \"content.body\" ], \n+        \n+        // include bundled child-event updates (default false) // V2.0\n+        bundle_updates: true,\n+        \n+        // include bundled related events: // V2.1\n+        bundle_relates_to: [\n+            {\n+                relationship: \"in_reply_to\",\n+                // As this is an optimisation to avoid having to explicitly select/paginate the\n+                // related messages per-message, we have to include a limit here as if we were\n+                // actually executing the query per-message for the initial result set.\n+                // Limit gives the number of related events to bundle; the bundled events return batch tokens\n+                // to let you seperately paginate on them.\n+                limit: 10, // maximum number of related events to bundle in the results of this filtered result set.\n+                ancestors: true, // include all ancestors (default: true)\n+                descendents: true, // include all descendents (default: true)\n+                \n+                <recursively include a filter definition here for the subset of events>\n+                // need to support a sort criteria which reflects the linearised ordering of the relation graph\n+            },\n+        ],\n+                \n+        // XXX: we may also want room_sort to specify the order of rooms returned by /sync,\n+        // as well as pagination for rooms returned by /sync...\n+    }\n+\n+Returns ``200 OK``::\n+    \n+    {\n+        \"filter_id\": \"583e98c2d983\"\n+    }\n+\n+\n+\"Sync API\" (was Event Stream API / Global initial sync API)\n+-----------------------------------------------------------\n+\n+There is no difference between an incremental initial sync of events and polling for updates on the eventstream.  They both transfer a delta of events from the server to the client, and both deltas need to be capped to avoid DoSing the client if too much time has elapsed between syncs.  Initial sync is thus a capped incremental delta of events relative to clean client-side state.\n+\n+Therefore we propose combining them into a single /sync API.  It's important to note that we should not design out server->client pushed event updates - the data returned by /sync polling should also be suitable for pushing if available (with suitable gapping/capping to avoid DoSing the client).  XXX: do this!\n+\n+``GET /sync``\n+\n+TODO: https://matrix.org/jira/browse/SYN-168\n+    /initialSync should return the actual m.room.member invite, not random keys from it\n+\n+GET parameters::\n+\n+    limit: maximum number of events per room to return.  If this limit is exceeded and gap is true:\n+            1. the server must flag the gap in the response (to avoid ambiguity between hitting the limit and exceeding the limit)\n+            2. the client must either throw away older timeline information or model a 'gap' in the timeline\n+            3. the server must include the full delta of state keys since the last sync, but will truncate the timeline delta.\n+           If this limit is exceeded and gap is false:\n+            1. we just send through the next batch of events in the next call to /sync, without any gapping.\n+           \n+    gap: boolean - should we drop events and do a non-delta sync for rooms whose limit is exceeded.  default: true.\n+\n+    // server-side sorting, so we can paginate events serverside on a thin client.\n+    // N.B. we can only order by unencrypted fields.\n+    // N.B. clients will need to handle out-of-order messages intelligently\n+    // N.B. subset of things you're allowed to sort by may be arbitrarily\n+    // restricted by the server impl (XXX: capabilities?)\n+    // Servers MUST support the \"timeline\" ordering - which is linearised logical chronological ordering.\n+    // N.B. This only takes effect when paginating, and is ignored for streaming data, and can only be specified once per filter.\n+    //\n+    // the sort order of messages in the room, *only honoured during an initial sync*. default: \"timeline,asc\". may appear multiple times\n+    // subsequent calls to /sync will always return event updates in timeline order (thanks to causality)\n+    // the batch tokens per-room are dependent on the sort order and cannot be mixed between different uses of the same filter.\n+    // the use case here is to start paginating a room sorted by not-timeline (e.g. by sender id - e.g. mail client use case)\n+    sort: fieldname, direction (e.g. \"sender,asc\",).\n+    \n+    // XXX: this needs to be made prettier.  you can't be a boolean because normal server behaviour allows small misorderings.\n+    // This this is an optimisation to allow thin clients to save bandwidth and not see out-of-order events which they can't\n+    // do anything useful with.  However, small races should be allowed.\n+    // v2.1\n+    // exclude_out_of_order_events_older_than: 10000 // ignore misorderings worse than 10s\n+    \n+    since: <batch token> to request an incremental delta since the specified batch token\n+        We call this 'since' rather than 'from' because it's not for pagination but a delta.\n+        The specified batch token would be taken from the most recent sync request that completed for this filter.\n+    timeout: maximum time to poll (in milliseconds) before returning this request. Only meaningful if performing an incremental sync (i.e. `since` is set)\n+        \n+    set_presence: \"offline\" // optional parameter to tell the server not to interpret this request as a client (device) as coming online (and as a convenience method for overriding presence state in general - e.g. setting straight to \"idle\" rather than having to PUT to /users/{userId}/devices/{deviceId}/presence.  It's meaningless to set \"online\" as that's the default behaviour on the server.)\n+        \n+    backfill: true/false (default true): do we want to pull in state from federation if we have less than <limit> events available for a room?\n+    \n+    filter: <filter_id> // filters can change between requests, to allow us to narrow down a global initial sync to a given room or similar use cases.\n+    // filter overrides (useful for changing filters between requests)\n+    filter_type: wildcard event type match e.g. \"m.*\", \"m.presence\": default, all.  may appear multiple times.\n+    filter_room: wildcard room id/name match e.g. \"!83wy7whi:matrix.org\": default, all.  may appear multiple times.\n+    filter_sender: wildcard sender id match e.g. \"@matthew:matrix.org\": default, all.  may appear multiple times.\n+    filter_event_id: event id to match e.g. \"$192318719:matrix.org\" // default, all: may appear multiple times\n+    filter_format: \"federation\" or \"events\"\n+    filter_select: event fields to return: default, all.  may appear multiple times\n+    filter_bundle_updates: true/false: default, false. bundle updates in events.\n+    // we deliberately don't specify filter_bundle_relates_to, as it's too hard to serialise into querystring params\n+\n+Returns ``200 OK``:\n+\n+.. code:: javascript\n+    \n+    {\n+        \"next_batch\": \"s72595_4483_1934\", // the batch token we pass to /sync's since param\n+        \n+        // updates about our own user data\n+        \"private_user_data\": [\n+            {\n+                \"event_id\": \"$15zxhijvwguye:matrix.org\",\n+                \"sender\": \"@matthew:tp.mu\"\n+                type: \"net.arasphere.weird.setting\",\n+                content: {\n+                    setting1: true,\n+                    setting2: false,\n+                }\n+            }\n+        ],",
    "path": "drafts/cs-v2-http-api.rst",
    "position": 191,
    "original_position": 173,
    "commit_id": "7b7d124f24272aeaa19444994e8e3d57cb353580",
    "original_commit_id": "bc087585232627c1354b4af694e990c02d78365a",
    "user": {
      "login": "ara4n",
      "id": 1294269,
      "avatar_url": "https://avatars.githubusercontent.com/u/1294269?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ara4n",
      "html_url": "https://github.com/ara4n",
      "followers_url": "https://api.github.com/users/ara4n/followers",
      "following_url": "https://api.github.com/users/ara4n/following{/other_user}",
      "gists_url": "https://api.github.com/users/ara4n/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ara4n/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ara4n/subscriptions",
      "organizations_url": "https://api.github.com/users/ara4n/orgs",
      "repos_url": "https://api.github.com/users/ara4n/repos",
      "events_url": "https://api.github.com/users/ara4n/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ara4n/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "[17:39]  <Arathorn> Mjark: for whether we should batch user_data... um... good question. given we don't paginate state yet, should we bother paginating presence & stuff?",
    "created_at": "2015-01-23T17:42:03Z",
    "updated_at": "2015-09-11T15:37:21Z",
    "html_url": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23466108",
    "pull_request_url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23466108"
      },
      "html": {
        "href": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23466108"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6"
      }
    }
  },
  {
    "url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23466121",
    "id": 23466121,
    "diff_hunk": "@@ -0,0 +1,553 @@\n+Client-Server v2 HTTP API Draft\n+===============================\n+\n+Filter API\n+----------\n+\n+The intersection of the parameters given defines the filter.  Unions of filters\n+can be achieved by querying multiple filters in parallel.\n+\n+XXX: Filters describe both what data to query and how to present it, so could\n+perhaps be better described as 'queries' or even 'subscriptions'?\n+\n+XXX: Is this actually sensible - should we instead have ordering & pagination &\n+limits etc provided per-query rather than lost in the filter?  Or you provide the\n+defaults in the filter definition, and then clobber them with query params.\n+\n+You can define a reusable filter with the below POST API.  The resulting filter_id\n+can then be passed to methods which can be filter.\n+\n+You can only create filters for your own user (filters are namespaced per user\n+as they are defined per-user data, like profiles etc)\n+\n+TODO: excluding filters (e.g. filter out \"org.matrix.neb.*\")\n+\n+XXX: how do we transition between non-coalesced pagination and coalesced pagination for related_to/updates\n+\n+::\n+\n+    POST /user/{userId}/filter\n+\n+.. code:: javascript    \n+    \n+    {\n+        // selectors: (bluntly selecting on the unencrypted fields)\n+        types: [ \"m.*\", \"net.arasphere.*\" ],    // default: all\n+        // N.B. types can be used to filter out presence and server-generated events (e.g. m.profile), but see *_user_data below\n+        not_types: [ \"m.presence\" ],            // default: none\n+        rooms: [ \"!83wy7whi:matrix.org\" ],      // default: all (may be aliases or IDs. wildcards supported)\n+        not_rooms: [],\n+        senders: [ \"@matthew:matrix.org\" ],  // default: all (e.g. for narrowing down presence, and stalker mode. wildcards supported)\n+        not_senders: [],\n+        \n+        public_user_data: true,  // include events describing public user data (as we might not know their types) - default: true\n+        private_user_data: true, // include events describing private user data (as we might not know their types) - default: true\n+        // XXX: How do these interact with specific type/non_type selectors prioritywise?\n+                \n+        // parameters\n+        \n+        // 'format' gives the desired shape of the response\n+        //   federation = include the federation layer as well as the raw content of events.\n+        //   events = the plain events\n+        format: \"federation\",\n+        \n+        // select specific specific fields of the event to be returned.\n+        // N.B. you cannot guaranteeing filter content fields as they may be encrypted.\n+        // e.g. selecting just event_id could be useful for doing server-side\n+        // sorting/pagination/threading\n+        select: [ \"event_id\", \"origin_server_ts\", \"thread_id\", \"content\", \"content.body\" ], \n+        \n+        // include bundled child-event updates (default false) // V2.0\n+        bundle_updates: true,\n+        \n+        // include bundled related events: // V2.1\n+        bundle_relates_to: [\n+            {\n+                relationship: \"in_reply_to\",\n+                // As this is an optimisation to avoid having to explicitly select/paginate the\n+                // related messages per-message, we have to include a limit here as if we were\n+                // actually executing the query per-message for the initial result set.\n+                // Limit gives the number of related events to bundle; the bundled events return batch tokens\n+                // to let you seperately paginate on them.\n+                limit: 10, // maximum number of related events to bundle in the results of this filtered result set.\n+                ancestors: true, // include all ancestors (default: true)\n+                descendents: true, // include all descendents (default: true)\n+                \n+                <recursively include a filter definition here for the subset of events>\n+                // need to support a sort criteria which reflects the linearised ordering of the relation graph\n+            },\n+        ],\n+                \n+        // XXX: we may also want room_sort to specify the order of rooms returned by /sync,\n+        // as well as pagination for rooms returned by /sync...\n+    }\n+\n+Returns ``200 OK``::\n+    \n+    {\n+        \"filter_id\": \"583e98c2d983\"\n+    }\n+\n+\n+\"Sync API\" (was Event Stream API / Global initial sync API)\n+-----------------------------------------------------------\n+\n+There is no difference between an incremental initial sync of events and polling for updates on the eventstream.  They both transfer a delta of events from the server to the client, and both deltas need to be capped to avoid DoSing the client if too much time has elapsed between syncs.  Initial sync is thus a capped incremental delta of events relative to clean client-side state.\n+\n+Therefore we propose combining them into a single /sync API.  It's important to note that we should not design out server->client pushed event updates - the data returned by /sync polling should also be suitable for pushing if available (with suitable gapping/capping to avoid DoSing the client).  XXX: do this!\n+\n+``GET /sync``\n+\n+TODO: https://matrix.org/jira/browse/SYN-168\n+    /initialSync should return the actual m.room.member invite, not random keys from it\n+\n+GET parameters::\n+\n+    limit: maximum number of events per room to return.  If this limit is exceeded and gap is true:\n+            1. the server must flag the gap in the response (to avoid ambiguity between hitting the limit and exceeding the limit)\n+            2. the client must either throw away older timeline information or model a 'gap' in the timeline\n+            3. the server must include the full delta of state keys since the last sync, but will truncate the timeline delta.\n+           If this limit is exceeded and gap is false:\n+            1. we just send through the next batch of events in the next call to /sync, without any gapping.\n+           \n+    gap: boolean - should we drop events and do a non-delta sync for rooms whose limit is exceeded.  default: true.\n+\n+    // server-side sorting, so we can paginate events serverside on a thin client.\n+    // N.B. we can only order by unencrypted fields.\n+    // N.B. clients will need to handle out-of-order messages intelligently\n+    // N.B. subset of things you're allowed to sort by may be arbitrarily\n+    // restricted by the server impl (XXX: capabilities?)\n+    // Servers MUST support the \"timeline\" ordering - which is linearised logical chronological ordering.\n+    // N.B. This only takes effect when paginating, and is ignored for streaming data, and can only be specified once per filter.\n+    //\n+    // the sort order of messages in the room, *only honoured during an initial sync*. default: \"timeline,asc\". may appear multiple times\n+    // subsequent calls to /sync will always return event updates in timeline order (thanks to causality)\n+    // the batch tokens per-room are dependent on the sort order and cannot be mixed between different uses of the same filter.\n+    // the use case here is to start paginating a room sorted by not-timeline (e.g. by sender id - e.g. mail client use case)\n+    sort: fieldname, direction (e.g. \"sender,asc\",).\n+    \n+    // XXX: this needs to be made prettier.  you can't be a boolean because normal server behaviour allows small misorderings.\n+    // This this is an optimisation to allow thin clients to save bandwidth and not see out-of-order events which they can't\n+    // do anything useful with.  However, small races should be allowed.\n+    // v2.1\n+    // exclude_out_of_order_events_older_than: 10000 // ignore misorderings worse than 10s\n+    \n+    since: <batch token> to request an incremental delta since the specified batch token\n+        We call this 'since' rather than 'from' because it's not for pagination but a delta.\n+        The specified batch token would be taken from the most recent sync request that completed for this filter.\n+    timeout: maximum time to poll (in milliseconds) before returning this request. Only meaningful if performing an incremental sync (i.e. `since` is set)\n+        \n+    set_presence: \"offline\" // optional parameter to tell the server not to interpret this request as a client (device) as coming online (and as a convenience method for overriding presence state in general - e.g. setting straight to \"idle\" rather than having to PUT to /users/{userId}/devices/{deviceId}/presence.  It's meaningless to set \"online\" as that's the default behaviour on the server.)\n+        \n+    backfill: true/false (default true): do we want to pull in state from federation if we have less than <limit> events available for a room?\n+    \n+    filter: <filter_id> // filters can change between requests, to allow us to narrow down a global initial sync to a given room or similar use cases.\n+    // filter overrides (useful for changing filters between requests)\n+    filter_type: wildcard event type match e.g. \"m.*\", \"m.presence\": default, all.  may appear multiple times.\n+    filter_room: wildcard room id/name match e.g. \"!83wy7whi:matrix.org\": default, all.  may appear multiple times.\n+    filter_sender: wildcard sender id match e.g. \"@matthew:matrix.org\": default, all.  may appear multiple times.\n+    filter_event_id: event id to match e.g. \"$192318719:matrix.org\" // default, all: may appear multiple times\n+    filter_format: \"federation\" or \"events\"\n+    filter_select: event fields to return: default, all.  may appear multiple times\n+    filter_bundle_updates: true/false: default, false. bundle updates in events.\n+    // we deliberately don't specify filter_bundle_relates_to, as it's too hard to serialise into querystring params\n+\n+Returns ``200 OK``:\n+\n+.. code:: javascript\n+    \n+    {\n+        \"next_batch\": \"s72595_4483_1934\", // the batch token we pass to /sync's since param\n+        \n+        // updates about our own user data\n+        \"private_user_data\": [\n+            {\n+                \"event_id\": \"$15zxhijvwguye:matrix.org\",\n+                \"sender\": \"@matthew:tp.mu\"\n+                type: \"net.arasphere.weird.setting\",\n+                content: {\n+                    setting1: true,\n+                    setting2: false,\n+                }\n+            }\n+        ],\n+                \n+        // updates about publically published users' data\n+        \"public_user_data\": [\n+            {\n+                \"event_id\": \"$14qwtyeufet783:matrix.org\",\n+                \"sender\": \"@matthew:tp.mu\"\n+                type: \"m.profile.avatar_url\",\n+                content: {\n+                    avatar_url: \"mxc://matrix.org/QG1hdHRoZXc6d\",\n+                }\n+            },\n+            {\n+                \"event_id\": \"$14qwtyeufet784:matrix.org\",\n+                \"sender\": \"@matthew:tp.mu\"\n+                type: \"m.profile.display_name\",\n+                content: {\n+                    display_name: \"Matthew\",\n+                }\n+            },\n+            {\n+                \"event_id\": \"$14qwtyeufet785:matrix.org\",\n+                \"sender\": \"@matthew:tp.mu\"\n+                type: \"m.presence\", // the global per-user presence as calculated serverside by aggregating the per-device presence data\n+                content: {\n+                    presence: \"idle\" // one of online/idle/offline\n+                    \"last_active\": 368200528, // when did the server last see proactive interaction from this user on any client.\n+                }\n+            },\n+        ],\n+        \n+        \"rooms\": [{       \n+            \"room_id\": \"!KrLWMLDnZAyTapqLWW:matrix.org\",\n+            \"limited\": true, // has the limit been exceeded for the number of events returned for this room? if so, the client should be aware that there's a gap in the event stream\n+            \"published\": true, // HS telling us that this room has been published in our aliases directory\n+         \n+            \"event_map\": {\n+                \"$1417731086506PgoVf:matrix.org\": {\n+                    \"type\": \"m.room.member\",\n+                    \"content\": {\n+                        \"membership\": \"join\"\n+                    },\n+                    \"origin_server_ts\": 1417731086795,",
    "path": "drafts/cs-v2-http-api.rst",
    "position": 233,
    "original_position": 215,
    "commit_id": "7b7d124f24272aeaa19444994e8e3d57cb353580",
    "original_commit_id": "bc087585232627c1354b4af694e990c02d78365a",
    "user": {
      "login": "ara4n",
      "id": 1294269,
      "avatar_url": "https://avatars.githubusercontent.com/u/1294269?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ara4n",
      "html_url": "https://github.com/ara4n",
      "followers_url": "https://api.github.com/users/ara4n/followers",
      "following_url": "https://api.github.com/users/ara4n/following{/other_user}",
      "gists_url": "https://api.github.com/users/ara4n/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ara4n/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ara4n/subscriptions",
      "organizations_url": "https://api.github.com/users/ara4n/orgs",
      "repos_url": "https://api.github.com/users/ara4n/repos",
      "events_url": "https://api.github.com/users/ara4n/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ara4n/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "[17:37]  <Arathorn> Mjark: for ordering key...\r\n[17:37]  <Arathorn> in /sync response\r\n[17:37]  <Arathorn> what were you/anyone thinking of?\r\n[17:37]  <Arathorn> prev_event: {event_id}?\r\n[17:38]  <Arathorn> or sort_order: {float}?\r\n[17:38]  <Arathorn> or tree-style index",
    "created_at": "2015-01-23T17:42:15Z",
    "updated_at": "2015-09-11T15:37:21Z",
    "html_url": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23466121",
    "pull_request_url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23466121"
      },
      "html": {
        "href": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23466121"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6"
      }
    }
  },
  {
    "url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23466133",
    "id": 23466133,
    "diff_hunk": "@@ -0,0 +1,553 @@\n+Client-Server v2 HTTP API Draft\n+===============================\n+\n+Filter API\n+----------\n+\n+The intersection of the parameters given defines the filter.  Unions of filters\n+can be achieved by querying multiple filters in parallel.\n+\n+XXX: Filters describe both what data to query and how to present it, so could\n+perhaps be better described as 'queries' or even 'subscriptions'?\n+\n+XXX: Is this actually sensible - should we instead have ordering & pagination &\n+limits etc provided per-query rather than lost in the filter?  Or you provide the\n+defaults in the filter definition, and then clobber them with query params.\n+\n+You can define a reusable filter with the below POST API.  The resulting filter_id\n+can then be passed to methods which can be filter.\n+\n+You can only create filters for your own user (filters are namespaced per user\n+as they are defined per-user data, like profiles etc)\n+\n+TODO: excluding filters (e.g. filter out \"org.matrix.neb.*\")\n+\n+XXX: how do we transition between non-coalesced pagination and coalesced pagination for related_to/updates\n+\n+::\n+\n+    POST /user/{userId}/filter\n+\n+.. code:: javascript    \n+    \n+    {\n+        // selectors: (bluntly selecting on the unencrypted fields)\n+        types: [ \"m.*\", \"net.arasphere.*\" ],    // default: all\n+        // N.B. types can be used to filter out presence and server-generated events (e.g. m.profile), but see *_user_data below\n+        not_types: [ \"m.presence\" ],            // default: none\n+        rooms: [ \"!83wy7whi:matrix.org\" ],      // default: all (may be aliases or IDs. wildcards supported)\n+        not_rooms: [],\n+        senders: [ \"@matthew:matrix.org\" ],  // default: all (e.g. for narrowing down presence, and stalker mode. wildcards supported)\n+        not_senders: [],\n+        \n+        public_user_data: true,  // include events describing public user data (as we might not know their types) - default: true\n+        private_user_data: true, // include events describing private user data (as we might not know their types) - default: true\n+        // XXX: How do these interact with specific type/non_type selectors prioritywise?\n+                \n+        // parameters\n+        \n+        // 'format' gives the desired shape of the response\n+        //   federation = include the federation layer as well as the raw content of events.\n+        //   events = the plain events\n+        format: \"federation\",\n+        \n+        // select specific specific fields of the event to be returned.\n+        // N.B. you cannot guaranteeing filter content fields as they may be encrypted.\n+        // e.g. selecting just event_id could be useful for doing server-side\n+        // sorting/pagination/threading\n+        select: [ \"event_id\", \"origin_server_ts\", \"thread_id\", \"content\", \"content.body\" ], \n+        \n+        // include bundled child-event updates (default false) // V2.0\n+        bundle_updates: true,\n+        \n+        // include bundled related events: // V2.1\n+        bundle_relates_to: [\n+            {\n+                relationship: \"in_reply_to\",\n+                // As this is an optimisation to avoid having to explicitly select/paginate the\n+                // related messages per-message, we have to include a limit here as if we were\n+                // actually executing the query per-message for the initial result set.\n+                // Limit gives the number of related events to bundle; the bundled events return batch tokens\n+                // to let you seperately paginate on them.\n+                limit: 10, // maximum number of related events to bundle in the results of this filtered result set.\n+                ancestors: true, // include all ancestors (default: true)\n+                descendents: true, // include all descendents (default: true)\n+                \n+                <recursively include a filter definition here for the subset of events>\n+                // need to support a sort criteria which reflects the linearised ordering of the relation graph\n+            },\n+        ],\n+                \n+        // XXX: we may also want room_sort to specify the order of rooms returned by /sync,\n+        // as well as pagination for rooms returned by /sync...\n+    }\n+\n+Returns ``200 OK``::\n+    \n+    {\n+        \"filter_id\": \"583e98c2d983\"\n+    }\n+\n+\n+\"Sync API\" (was Event Stream API / Global initial sync API)\n+-----------------------------------------------------------\n+\n+There is no difference between an incremental initial sync of events and polling for updates on the eventstream.  They both transfer a delta of events from the server to the client, and both deltas need to be capped to avoid DoSing the client if too much time has elapsed between syncs.  Initial sync is thus a capped incremental delta of events relative to clean client-side state.\n+\n+Therefore we propose combining them into a single /sync API.  It's important to note that we should not design out server->client pushed event updates - the data returned by /sync polling should also be suitable for pushing if available (with suitable gapping/capping to avoid DoSing the client).  XXX: do this!\n+\n+``GET /sync``\n+\n+TODO: https://matrix.org/jira/browse/SYN-168\n+    /initialSync should return the actual m.room.member invite, not random keys from it\n+\n+GET parameters::\n+\n+    limit: maximum number of events per room to return.  If this limit is exceeded and gap is true:\n+            1. the server must flag the gap in the response (to avoid ambiguity between hitting the limit and exceeding the limit)\n+            2. the client must either throw away older timeline information or model a 'gap' in the timeline\n+            3. the server must include the full delta of state keys since the last sync, but will truncate the timeline delta.\n+           If this limit is exceeded and gap is false:\n+            1. we just send through the next batch of events in the next call to /sync, without any gapping.\n+           \n+    gap: boolean - should we drop events and do a non-delta sync for rooms whose limit is exceeded.  default: true.\n+\n+    // server-side sorting, so we can paginate events serverside on a thin client.\n+    // N.B. we can only order by unencrypted fields.\n+    // N.B. clients will need to handle out-of-order messages intelligently\n+    // N.B. subset of things you're allowed to sort by may be arbitrarily\n+    // restricted by the server impl (XXX: capabilities?)\n+    // Servers MUST support the \"timeline\" ordering - which is linearised logical chronological ordering.\n+    // N.B. This only takes effect when paginating, and is ignored for streaming data, and can only be specified once per filter.\n+    //\n+    // the sort order of messages in the room, *only honoured during an initial sync*. default: \"timeline,asc\". may appear multiple times\n+    // subsequent calls to /sync will always return event updates in timeline order (thanks to causality)",
    "path": "drafts/cs-v2-http-api.rst",
    "position": null,
    "original_position": 124,
    "commit_id": "7b7d124f24272aeaa19444994e8e3d57cb353580",
    "original_commit_id": "bc087585232627c1354b4af694e990c02d78365a",
    "user": {
      "login": "ara4n",
      "id": 1294269,
      "avatar_url": "https://avatars.githubusercontent.com/u/1294269?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ara4n",
      "html_url": "https://github.com/ara4n",
      "followers_url": "https://api.github.com/users/ara4n/followers",
      "following_url": "https://api.github.com/users/ara4n/following{/other_user}",
      "gists_url": "https://api.github.com/users/ara4n/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ara4n/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ara4n/subscriptions",
      "organizations_url": "https://api.github.com/users/ara4n/orgs",
      "repos_url": "https://api.github.com/users/ara4n/repos",
      "events_url": "https://api.github.com/users/ara4n/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ara4n/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "done",
    "created_at": "2015-01-23T17:42:35Z",
    "updated_at": "2015-09-11T15:37:21Z",
    "html_url": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23466133",
    "pull_request_url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23466133"
      },
      "html": {
        "href": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23466133"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6"
      }
    }
  },
  {
    "url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23468624",
    "id": 23468624,
    "diff_hunk": "@@ -0,0 +1,553 @@\n+Client-Server v2 HTTP API Draft\n+===============================\n+\n+Filter API\n+----------\n+\n+The intersection of the parameters given defines the filter.  Unions of filters\n+can be achieved by querying multiple filters in parallel.\n+\n+XXX: Filters describe both what data to query and how to present it, so could\n+perhaps be better described as 'queries' or even 'subscriptions'?\n+\n+XXX: Is this actually sensible - should we instead have ordering & pagination &\n+limits etc provided per-query rather than lost in the filter?  Or you provide the\n+defaults in the filter definition, and then clobber them with query params.\n+\n+You can define a reusable filter with the below POST API.  The resulting filter_id\n+can then be passed to methods which can be filter.\n+\n+You can only create filters for your own user (filters are namespaced per user\n+as they are defined per-user data, like profiles etc)\n+\n+TODO: excluding filters (e.g. filter out \"org.matrix.neb.*\")\n+\n+XXX: how do we transition between non-coalesced pagination and coalesced pagination for related_to/updates\n+\n+::\n+\n+    POST /user/{userId}/filter\n+\n+.. code:: javascript    \n+    \n+    {\n+        // selectors: (bluntly selecting on the unencrypted fields)\n+        types: [ \"m.*\", \"net.arasphere.*\" ],    // default: all\n+        // N.B. types can be used to filter out presence and server-generated events (e.g. m.profile), but see *_user_data below\n+        not_types: [ \"m.presence\" ],            // default: none\n+        rooms: [ \"!83wy7whi:matrix.org\" ],      // default: all (may be aliases or IDs. wildcards supported)\n+        not_rooms: [],\n+        senders: [ \"@matthew:matrix.org\" ],  // default: all (e.g. for narrowing down presence, and stalker mode. wildcards supported)\n+        not_senders: [],\n+        \n+        public_user_data: true,  // include events describing public user data (as we might not know their types) - default: true\n+        private_user_data: true, // include events describing private user data (as we might not know their types) - default: true\n+        // XXX: How do these interact with specific type/non_type selectors prioritywise?\n+                \n+        // parameters\n+        \n+        // 'format' gives the desired shape of the response\n+        //   federation = include the federation layer as well as the raw content of events.\n+        //   events = the plain events\n+        format: \"federation\",\n+        \n+        // select specific specific fields of the event to be returned.\n+        // N.B. you cannot guaranteeing filter content fields as they may be encrypted.\n+        // e.g. selecting just event_id could be useful for doing server-side\n+        // sorting/pagination/threading\n+        select: [ \"event_id\", \"origin_server_ts\", \"thread_id\", \"content\", \"content.body\" ], \n+        \n+        // include bundled child-event updates (default false) // V2.0\n+        bundle_updates: true,\n+        \n+        // include bundled related events: // V2.1\n+        bundle_relates_to: [\n+            {\n+                relationship: \"in_reply_to\",\n+                // As this is an optimisation to avoid having to explicitly select/paginate the\n+                // related messages per-message, we have to include a limit here as if we were\n+                // actually executing the query per-message for the initial result set.\n+                // Limit gives the number of related events to bundle; the bundled events return batch tokens\n+                // to let you seperately paginate on them.\n+                limit: 10, // maximum number of related events to bundle in the results of this filtered result set.\n+                ancestors: true, // include all ancestors (default: true)\n+                descendents: true, // include all descendents (default: true)\n+                \n+                <recursively include a filter definition here for the subset of events>\n+                // need to support a sort criteria which reflects the linearised ordering of the relation graph\n+            },\n+        ],\n+                \n+        // XXX: we may also want room_sort to specify the order of rooms returned by /sync,\n+        // as well as pagination for rooms returned by /sync...\n+    }\n+\n+Returns ``200 OK``::\n+    \n+    {\n+        \"filter_id\": \"583e98c2d983\"\n+    }\n+\n+\n+\"Sync API\" (was Event Stream API / Global initial sync API)\n+-----------------------------------------------------------\n+\n+There is no difference between an incremental initial sync of events and polling for updates on the eventstream.  They both transfer a delta of events from the server to the client, and both deltas need to be capped to avoid DoSing the client if too much time has elapsed between syncs.  Initial sync is thus a capped incremental delta of events relative to clean client-side state.\n+\n+Therefore we propose combining them into a single /sync API.  It's important to note that we should not design out server->client pushed event updates - the data returned by /sync polling should also be suitable for pushing if available (with suitable gapping/capping to avoid DoSing the client).  XXX: do this!\n+\n+``GET /sync``\n+\n+TODO: https://matrix.org/jira/browse/SYN-168\n+    /initialSync should return the actual m.room.member invite, not random keys from it\n+\n+GET parameters::\n+\n+    limit: maximum number of events per room to return.  If this limit is exceeded and gap is true:\n+            1. the server must flag the gap in the response (to avoid ambiguity between hitting the limit and exceeding the limit)\n+            2. the client must either throw away older timeline information or model a 'gap' in the timeline\n+            3. the server must include the full delta of state keys since the last sync, but will truncate the timeline delta.\n+           If this limit is exceeded and gap is false:\n+            1. we just send through the next batch of events in the next call to /sync, without any gapping.\n+           \n+    gap: boolean - should we drop events and do a non-delta sync for rooms whose limit is exceeded.  default: true.\n+\n+    // server-side sorting, so we can paginate events serverside on a thin client.\n+    // N.B. we can only order by unencrypted fields.\n+    // N.B. clients will need to handle out-of-order messages intelligently\n+    // N.B. subset of things you're allowed to sort by may be arbitrarily\n+    // restricted by the server impl (XXX: capabilities?)\n+    // Servers MUST support the \"timeline\" ordering - which is linearised logical chronological ordering.\n+    // N.B. This only takes effect when paginating, and is ignored for streaming data, and can only be specified once per filter.\n+    //\n+    // the sort order of messages in the room, *only honoured during an initial sync*. default: \"timeline,asc\". may appear multiple times\n+    // subsequent calls to /sync will always return event updates in timeline order (thanks to causality)\n+    // the batch tokens per-room are dependent on the sort order and cannot be mixed between different uses of the same filter.\n+    // the use case here is to start paginating a room sorted by not-timeline (e.g. by sender id - e.g. mail client use case)\n+    sort: fieldname, direction (e.g. \"sender,asc\",).\n+    \n+    // XXX: this needs to be made prettier.  you can't be a boolean because normal server behaviour allows small misorderings.\n+    // This this is an optimisation to allow thin clients to save bandwidth and not see out-of-order events which they can't\n+    // do anything useful with.  However, small races should be allowed.\n+    // v2.1\n+    // exclude_out_of_order_events_older_than: 10000 // ignore misorderings worse than 10s\n+    \n+    since: <batch token> to request an incremental delta since the specified batch token\n+        We call this 'since' rather than 'from' because it's not for pagination but a delta.\n+        The specified batch token would be taken from the most recent sync request that completed for this filter.\n+    timeout: maximum time to poll (in milliseconds) before returning this request. Only meaningful if performing an incremental sync (i.e. `since` is set)\n+        \n+    set_presence: \"offline\" // optional parameter to tell the server not to interpret this request as a client (device) as coming online (and as a convenience method for overriding presence state in general - e.g. setting straight to \"idle\" rather than having to PUT to /users/{userId}/devices/{deviceId}/presence.  It's meaningless to set \"online\" as that's the default behaviour on the server.)\n+        \n+    backfill: true/false (default true): do we want to pull in state from federation if we have less than <limit> events available for a room?\n+    \n+    filter: <filter_id> // filters can change between requests, to allow us to narrow down a global initial sync to a given room or similar use cases.\n+    // filter overrides (useful for changing filters between requests)\n+    filter_type: wildcard event type match e.g. \"m.*\", \"m.presence\": default, all.  may appear multiple times.\n+    filter_room: wildcard room id/name match e.g. \"!83wy7whi:matrix.org\": default, all.  may appear multiple times.\n+    filter_sender: wildcard sender id match e.g. \"@matthew:matrix.org\": default, all.  may appear multiple times.\n+    filter_event_id: event id to match e.g. \"$192318719:matrix.org\" // default, all: may appear multiple times\n+    filter_format: \"federation\" or \"events\"\n+    filter_select: event fields to return: default, all.  may appear multiple times\n+    filter_bundle_updates: true/false: default, false. bundle updates in events.\n+    // we deliberately don't specify filter_bundle_relates_to, as it's too hard to serialise into querystring params\n+\n+Returns ``200 OK``:\n+\n+.. code:: javascript\n+    \n+    {\n+        \"next_batch\": \"s72595_4483_1934\", // the batch token we pass to /sync's since param\n+        \n+        // updates about our own user data\n+        \"private_user_data\": [\n+            {\n+                \"event_id\": \"$15zxhijvwguye:matrix.org\",\n+                \"sender\": \"@matthew:tp.mu\"\n+                type: \"net.arasphere.weird.setting\",\n+                content: {\n+                    setting1: true,\n+                    setting2: false,\n+                }\n+            }\n+        ],\n+                \n+        // updates about publically published users' data\n+        \"public_user_data\": [\n+            {\n+                \"event_id\": \"$14qwtyeufet783:matrix.org\",\n+                \"sender\": \"@matthew:tp.mu\"\n+                type: \"m.profile.avatar_url\",\n+                content: {\n+                    avatar_url: \"mxc://matrix.org/QG1hdHRoZXc6d\",\n+                }\n+            },\n+            {\n+                \"event_id\": \"$14qwtyeufet784:matrix.org\",\n+                \"sender\": \"@matthew:tp.mu\"\n+                type: \"m.profile.display_name\",\n+                content: {\n+                    display_name: \"Matthew\",\n+                }\n+            },\n+            {\n+                \"event_id\": \"$14qwtyeufet785:matrix.org\",\n+                \"sender\": \"@matthew:tp.mu\"\n+                type: \"m.presence\", // the global per-user presence as calculated serverside by aggregating the per-device presence data\n+                content: {\n+                    presence: \"idle\" // one of online/idle/offline\n+                    \"last_active\": 368200528, // when did the server last see proactive interaction from this user on any client.\n+                }\n+            },\n+        ],\n+        \n+        \"rooms\": [{       \n+            \"room_id\": \"!KrLWMLDnZAyTapqLWW:matrix.org\",\n+            \"limited\": true, // has the limit been exceeded for the number of events returned for this room? if so, the client should be aware that there's a gap in the event stream\n+            \"published\": true, // HS telling us that this room has been published in our aliases directory\n+         \n+            \"event_map\": {\n+                \"$1417731086506PgoVf:matrix.org\": {\n+                    \"type\": \"m.room.member\",\n+                    \"content\": {\n+                        \"membership\": \"join\"\n+                    },\n+                    \"origin_server_ts\": 1417731086795,\n+                    \"state_key\": \"@matthew:matrix.org\",\n+                    \"sender\": \"@matthew:matrix.org\"    \n+                },\n+        \n+                \"$13275681auxsabj:matrix.org\": {\n+                    \"type\": \"m.room.member.profile\",\n+                    content: {\n+                        \"avatar_url\": \"mxc://matrix.org/QG1hdHRoZXc6d\",\n+                        \"displayname\": \"Matthew\",\n+                    },\n+                    prev_content: {\n+                        \"avatar_url\": \"mxc://matrix.org/QG1hdHRoZXc6d\",\n+                        \"displayname\": \"Arathorn\",\n+                    },\n+                    \"origin_server_ts\": 1417731086796,\n+                    \"state_key\": \"@matthew:matrix.org\",\n+                    \"sender\": \"@matthew:matrix.org\"    \n+                },\n+\n+                \"$15e789t23987:matrix.org\": {\n+                    \"type\": \"m.room.message\",\n+                    \"unsigned\": {\n+                        \"age\": \"124524\",\n+                        \"txn_id\": \"1234\", // the transaction ID that the client specified in /send/{event_type}\n+                    },\n+                    content: {\n+                        \"body\": \"I am a fish\",\n+                        \"msgtype\": \"m.text\",\n+                    },\n+                    \"origin_server_ts\": 1417731086797,\n+                    \"sender\": \"@matthew:matrix.org\"    \n+                },\n+            },\n+        \n+            // \"membership\": \"join\",  // this now gets removed as redundant with state object, likewise invite keys (i.e. \"invitee\")\n+            \"events\": { // rename messages to events as this is a list of all events, not just messages (non-state events).\n+                        // gives a list of events, limited to $limit in length\n+                \"batch\": [\n+                    \"$1417731086506PgoVf:matrix.org\",\n+                    \"$13275681auxsabj:matrix.org\",\n+                    \"$15e789t23987:matrix.org\", ...\n+                ],\n+                \n+                // We don't have a next_batch because if we want to stream forwards we use\n+                // GET /sync?since=batch&filter_room=!KrLWMLDnZAyTapqLWW:matrix.org\n+                \n+                \"prev_batch\": \"t67-41151_4483_1934\" // for scrollback.\n+                // N.B. if you use prev_batch to scroll backwards you will receive events you already saw\n+                // if you have been calling /sync multiple times.  This is only useful for really thin clients.\n+                // If the client is tracking client-side history, then they should only store the prev_batch if\n+                // `limited` is true.\n+            },\n+\n+            \"state\": [\n+                \"$1417731086506PgoVf:matrix.org\"\n+                \"$13275681auxsabj:matrix.org\", ...\n+            ],",
    "path": "drafts/cs-v2-http-api.rst",
    "position": 290,
    "original_position": 272,
    "commit_id": "7b7d124f24272aeaa19444994e8e3d57cb353580",
    "original_commit_id": "bc087585232627c1354b4af694e990c02d78365a",
    "user": {
      "login": "ara4n",
      "id": 1294269,
      "avatar_url": "https://avatars.githubusercontent.com/u/1294269?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ara4n",
      "html_url": "https://github.com/ara4n",
      "followers_url": "https://api.github.com/users/ara4n/followers",
      "following_url": "https://api.github.com/users/ara4n/following{/other_user}",
      "gists_url": "https://api.github.com/users/ara4n/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ara4n/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ara4n/subscriptions",
      "organizations_url": "https://api.github.com/users/ara4n/orgs",
      "repos_url": "https://api.github.com/users/ara4n/repos",
      "events_url": "https://api.github.com/users/ara4n/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ara4n/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "The point of the event_map is to reduce duplicated data over the line protocol, not hardcode lookups into the data structure. Given the event_map will need to be expanded out clientside anyway, i'm not sure there's much point in optimising for lookups like this...",
    "created_at": "2015-01-23T18:23:02Z",
    "updated_at": "2015-09-11T15:37:21Z",
    "html_url": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23468624",
    "pull_request_url": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/comments/23468624"
      },
      "html": {
        "href": "https://github.com/matrix-org/matrix-doc/pull/6#discussion_r23468624"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/matrix-org/matrix-doc/pulls/6"
      }
    }
  }
]
